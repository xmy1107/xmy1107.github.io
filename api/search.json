[{"id":"eb0a8ca2a9fe3a4a83b3dd3030d852a2","title":"重要文件同步记录","content":"电脑文件/手机中图片视频等：夸克网盘增量同步\nObsidian上笔记/Zotero上论文：WebDAV全量同步，服务器为InfiniCLOUD\n手机备忘录/录音：小米云盘备份\nnotability中笔记：OneDrive -&gt; WebDAV全量同步\n","slug":"重要文件同步记录","date":"2025-08-25T11:45:40.000Z","categories_index":"","tags_index":"杂","author_index":"蜗角虚名羊"},{"id":"7989d0bc516394041acffec0190067a2","title":"专业课复习","content":"C/C++\nconst\n\n\n\n\n\n\n\n\n\n（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变\n1234const int *p=&amp;a,r=10;//指向常量的指针（const 后面是 int，说明指向的整形变量不可改变）int* const q=&amp;a;//自身是常量的指针int *t=r;//这句错误，前必须加constint* const s;//这句编译错误，必须初始化，否则定义了一个永久野指针\n\n\n\n指向常量的指针\n自身是常量的指针\n\n\n\n\n可以同时定义别的常量\n无法一句话中定义多个变量\n\n\n可以不立即初始化\n必须初始化，否则无意义\n\n\n\n","slug":"专业课复习","date":"2025-08-25T11:19:46.000Z","categories_index":"","tags_index":"杂","author_index":"蜗角虚名羊"},{"id":"fe9abd9ce7a18acea215fd553ff20b5e","title":"alphageometry复现","content":"Code\n项目链接\nfixed：numericals.py\tcheck_cyclic\t(a, b, c), *ps = points =&gt; a, b, c, *ps = points\nMethod\n论文概要\nAlphaGeometry Syntax\n解读1（from知乎）\n解读2（from谷歌共享文档）\n解读3（from某github项目）\n原语：\ncoll a b c : points a b c are collinear\ncong a b c e : segments ab and cd are congruent (length equal)\ncontri a b c p q r : triangles abc and pqr are congruent\ncyclic a b c d : 4 points a b c d are cocyclic\neqangle a b c d p q r s : the angles between lines ab-cd and pq-rs are equal. Note that angles have directions (signs) so the order between a b and c d matters. eqangle a b c d c d a b is false. The way to think about it is, angle ab-cd is the angle to turn line ab clockwise so it is parallel with the line cd. You can use counter-clockwise as the convention too, as long as for all angles the same convention is used\neqratio a b c d p q r s : segment length ab/cd = pq/rs\nmidp m a b : point m is the midpoint of a and b\npara a b c d : segments ab and cd are parallel\nperp a b c d : segments ab and cd are perpendicular to each other\nsimtri a b c p q r : triangles abc and pqr are similar\nDD推导的公式基于rules.txt：\n12345perp A B C D, perp C D E F, ncoll A B E =&gt; para A B E F\t\t# AB ⊥ CD, CD ⊥ EF, ABE不共线 =&gt; AB // EFcong O A O B, cong O B O C, cong O C O D =&gt; cyclic A B C D\t# OA = OB, OB = OC, OC = OD =&gt; ABCD共圆eqangle A B P Q C D P Q =&gt; para A B C Dcyclic A B P Q =&gt; eqangle P A P B Q A Q B......\n所有的操作都记录在defs.txt中，操作表：\n六行为一组：construction, rely, deps, basics, numerics, _ = data.split('\\n')\n123456789101112angle_mirror x a b c\t\t\t# 对角abc以bc为对称轴作镜像反转x : a b c x\t\t\t\t\t\t# x由abcx决定a b c = ncoll a b c\t\t\t\t# abc需要满足的条件x : eqangle b a b c b c b x\t\t# ∠abc = ∠xbcamirror a b c\t\t\t\t\t# 另一种表示circle x a b c\t\t\t\t\t# 定义x为由abc确定的圆的圆心x : a b ca b c = ncoll a b cx : cong x a x b, cong x b x c\t# xa = xb = xcbline a b, bline a c\t\t\t# bline代表中垂线，这句是第一句的另一种表示......\n点+ ‘=’ + 1-2个操作 =&gt; 点的构造，点的构造间用分号分隔。以一道证明垂心的题举例：\n123orthocentera b c = triangle; h = on_tline b a c, on_tline c a b ? perp a h b c# abc为一三角形；hb ⊥ ac 并且 hc ⊥ ab。证明ha垂直bc\ntips：\n空格敏感，出现一个多余空格，哪怕不是在当前题目中，也会无法运行\nConfiguration\nissue：GPU用不了\nmeliad库需要git checkout e8af054\nData Generation\n随机生成图\nimage_generate.py将常用的一些操作分为三类调用，除了第一句的segment a b或triangle a b c外，剩下每轮加一个点，每个点用以下三类调用中的其中一种生成\n第三类调用较为特殊，可以通过生成两个条件，即两条线唯一确定一个点，也可以只生成一个条件，表明点在这条线上。\n123calls1 = [\"circle\"]               # 3 点 → 点calls2 = [\"midpoint\", \"mirror\"]   # 2 点 → 点calls3 = [\"on_line\",\"on_tline\",\"on_bline\",\"on_circle\",\"on_pline\"]  # 2 点 → 线\n可视化\ndraw.py 利用 DDAR 中提供的 graph 等模块用于可视化，便于debug。由于上面的随机生成图不是一道完整的题目，没有证明目标 goal ，所以自然不能 write_solution 和结合 premises 和 goal 检验题目的正确性，graph.py 内 build_problem对应的部分要注释掉。\n加入发现辅助点模块\n随机生成的图是依次加点实现的，在加点过程中，如果产生了新的结论，且新的结论中包含的点不含这个新加的点，说明新点是辅助点。\nddar.get_proof_steps 等地方提供的方法只能由 goal 出发生成依赖关系，但由前文所述，随机生成的内容不包含 goal，自己手动造结论很可能出现冲突导致异常，造出正确且不是条件中的结论很难，急需一个遍历所有结论的方法。\n如果对 trace_back.py geometry.py等代码有足够深的理解可能可以直接调用其数据结构，我能想到的替代方案是在 graph.py 中 add_algebra 中加一句 self.all_conclusions.append([name] + [a.name for a in args])，可以收集所有可达结论（后面提到这里的结论是假的，不全的）。\n然后便遇到了同构问题，在规定其格式后解决，但依然会有“假”辅助点。因为DDAR虽然是一直运行到结论形成闭包，但内部并不是将所有结论存起来，而是将父类Node 分为 Point,Line,Angle 等子类，所谓的闭包是说这些子类之间无法产生新的结论。只能通过 check 得到单对 Node 之间的关系。不过这个问题只要调用 write_solution 进行进一步检验即可，在输出证明过程的时候会输出其中的辅助点，不为空即可行。\n之后又碰到一个新问题，即便 DDAR 引擎判为辅助点也不代表这个点非加不可，只能是这个证明中必须要这个点，删掉以后就不成立；实际的辅助点需要对于任意证明都需要加这样一个新的点。不过这样训出来的模型可以添加 DDAR 认为是辅助点的点。\nTODO：用枚举方法生成结论，生成更高质量的数据\n生成数据\n训练模型\nOpenNMT\nEncoutered problems\n\n有AB = BC, AB = AD，但无AC = BD。这里的发现让我多一层检查：将最新加的点删除如果依然能证明说明这个点不算辅助点。\n\n\n\n\n\n垂心的结论去掉以后，光由DDAR推导无法推到该结论，说明结论应当通过枚举获得。\n\n\n这里的∠(EB-CD) = ∠(EC-AB)是对的，开始搞错了\n\n\n\n\n能训出让DDAR认为是辅助点的辅助点添加建议\n\n\n","slug":"alphageometry复现","date":"2025-07-03T10:48:15.000Z","categories_index":"","tags_index":"","author_index":"蜗角虚名羊"},{"id":"790f0da8c2ac27cfc9217b88b39debdd","title":"大模型学习","content":"知识点：\n\n\nRNN：用于处理序列数据的神经网络，比FNN多“记忆”能力\nhttps://www.runoob.com/nlp/recurrent-neural-network.html\n\n\nCNN：\nhttps://blog.csdn.net/Gupao123/article/details/148131303?spm=1001.2014.3001.5502\n\n\n\n","slug":"大模型学习","date":"2025-07-01T22:01:02.000Z","categories_index":"","tags_index":"大模型","author_index":"蜗角虚名羊"},{"id":"a553eb0311e988c9770df911f4500d61","title":"图形学知识点记录","content":"头歌图形学平台链接\n\n曲线/曲面绘制\n\n\nde Casteljau算法：重复线性插值\n\n\n调和函数：最终结果（二次项系数）\n\n\nrationalBezier：bernstein基函数基础上乘上权重\n\n\nBezier曲面：本质将Bezier曲线扩展到二维\n\n\n\n\n\n\n\n\n三角形填充\n\n重心坐标法：枚举bounding box每个点，根据重心坐标判断是否在三角形内\n同侧判断法：枚举bounding box每个点，判断是否在三条边的“右侧”\n扫描线法：从下往上扫描每条线，每次找这条线上三角形的左右边界，分成两个小三角形分类讨论，每一块都按比例算一下即可算出坐标\n\n\n\n多边形填充\n\n扫描线填充算法（活动边表AET法）：把每条边miny顶点放进NET(Network Table)中，只记录x,dx,ymax（每个顶点有左上和右上两组）。y在miny到maxy遍历的时候，若比某个NET大了就从NET转移到AET(Active Edge Table)，大于顶点的ymax了就删除，这样就能得到这条扫描线和多边形的所有交点。对x排序后按两个一组着色即可。\n边缘填充法：先求出多边形的每条边与扫描线的交点，然后将交点右侧的所有像素颜色全部取为补色。实际写起来很简单，用任何方式把整个多边形的每个点遍历一遍即可。\n区域四连通种子填充算法：dfs\n区域扫描线种子填充算法：初始一个种子，然后x方向上不断往上往下扩展新种子，每个种子都可以向左向右一直着色到碰到边界left,right为止。新种子的确定是[left+1,right-1]若碰到边界点就多拆一个种子。下图不需要担心凹下的部分被着色。因为从下往上扩展的过程会先碰到顶点，已经被拆成两个小种子继续着色左上角和右上角了，不用担心变成三块，把中间也着色。\n\n\n\n\n","slug":"图形学知识点记录","date":"2025-05-29T16:46:22.000Z","categories_index":"","tags_index":"图形学","author_index":"蜗角虚名羊"},{"id":"6439e963f0ca8d84d8d591c83d0592ca","title":"Azure上创建和使用虚拟机","content":"不要忽略下面这行\n服务器一直要扣费，又重新配置了一下（还是要扣费），用户xmy，ip：52.230.67.203\nStep 1：预备步骤\n参照链接，使用Azure学生订阅创建免费的Linux服务器。其中学生认证用github登录的话能方便很多。创建服务器后，用ssh连接即可进入虚拟机\n此处注意azure默认用户是azureuser，我猜了半天\n第一次登录指令是ssh -i AzureServer_key.pem azureuser@52.163.103.91，通过私钥登录\n之后可以本地cat ~/.ssh/id_ed25519.pub获取公钥后，vim .ssh/authorized_keys加到服务器中，即可直接ssh azureuser@52.163.103.91登录（现在不行了，得ssh -i /home/xmy/.ssh/id_ed25519 xmy@52.230.67.203，呜呜呜，但确实初始登录是服务器生成密钥，密钥由云平台控制，安全性较低；后续登录时客户端生成密钥但需要手动配置公钥到服务器）\n不过可以配置~/.ssh/config，进行如下配置后即可直接ssh myserver登录：\n1234Host myserver  HostName 52.230.67.203  User xmy  IdentityFile ~/.ssh/id_ed25519\n阿里云下注册一个域名xmy.zone：\n\nStep 2：配置frps\n过程可以参考frp参考文档\nbash中的操作也不需要额外讲解了，说几个注意点：\n\n\nfrps 和 frpc 不要搞错\n\n\n老版本的配置文件是 frps.ini ，新版是 frps.toml ，并且新版采取驼峰命名法，而不是蛇形命名法\n\n\n最好重命名一下下载下来的文件夹为frp，之后总要用到，太长不方便\n\n\n配置 /etc/systemd/system/frps.service 时软链接到 /home/azureuser/frp/frps.service 会方便很多，并且软链接最好都用绝对路径\n\n\n1234567891011121314151617181920212223242526272829(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/Azure$ ssh -i AzureServer_key.pem azureuser@52.163.103.91Welcome to Ubuntu 22.04.5 LTS (GNU/Linux 6.8.0-1021-azure x86_64)（省略欢迎页面）azureuser@AzureServer:~$ wget https://github.com/fatedier/frp/releases/download/v0.61.1/frp_0.61.1_linux_amd64.tar.gz--2025-03-02 07:24:38--  https://github.com/fatedier/frp/releases/download/v0.37.0/frp_0.37.0_linux_amd64.tar.gz（省略下载过程）azureuser@AzureServer:~$ tar -xvf frp_0.61.1_linux_amd64.tar.gz frp_0.61.1_linux_amd64/frp_0.61.1_linux_amd64/frpcfrp_0.61.1_linux_amd64/frpsfrp_0.61.1_linux_amd64/LICENSEfrp_0.61.1_linux_amd64/frpc.tomlfrp_0.61.1_linux_amd64/frps.tomlazureuser@AzureServer:~$ cd frp_0.61.1_linux_amd64/azureuser@AzureServer:~/frp_0.61.1_linux_amd64$ vim frps.tomlazureuser@AzureServer:~/frp_0.61.1_linux_amd64$ vim frps.serviceazureuser@AzureServer:~/frp_0.61.1_linux_amd64$ cd ..azureuser@AzureServer:~$ mv frp_0.61.1_linux_amd64 frpazureuser@AzureServer:~$ cd frpazureuser@AzureServer:~/frp$ pwd/home/azureuser/frpazureuser@AzureServer:~/frp$ sudo ln -s /home/azureuser/frp/frps.service /etc/systemd/system/frps.serviceazureuser@AzureServer:~/frp$ sudo systemctl daemon-reloadazureuser@AzureServer:~/frp$ sudo systemctl enable frpsCreated symlink /etc/systemd/system/multi-user.target.wants/frps.service → /home/azureuser/frp/frps.service.azureuser@AzureServer:~/frp$ sudo systemctl start frpsazureuser@AzureServer:~/frp$ sudo systemctl status frps● frps.service - frps (Fast Reverse Proxy Server)（省略一万字，总之配置成功）\n其中frps.toml配置如下：\n1bindPort = 7000\nfrps.service配置如下：\n12345678910111213[Unit]Description=frps (Fast Reverse Proxy Server)After=network.target[Service]Type=simpleUser=rootExecStart=/home/azureuser/frp/frps -c /home/azureuser/frp/frps.tomlRestart=on-failureLimitNOFILE=4096[Install]WantedBy=multi-user.target\nStep 3：配置frpc\n流程与配置 frps 基本相同，这里记录如下几点：\n需要在 Azure 的网络设置中添加入站端口规则，否则会出现：\n123456(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/frp_0.61.1_linux_amd64$ ./frpc -c frpc.toml2025-03-02 15:45:25.171 [I] [sub/root.go:142] start frpc service for config file [frpc.toml]2025-03-02 15:45:25.171 [I] [client/service.go:295] try to connect to server...2025-03-02 15:45:32.689 [W] [client/service.go:298] connect to server error: EOF2025-03-02 15:45:32.689 [I] [sub/root.go:160] frpc service for config file [frpc.toml] stoppedlogin to the server failed: EOF. With loginFailExit enabled, no additional retries will be attempted\n\nfrpc.toml配置如下：\n123456789serverAddr = \"xmy.zone\"serverPort = 7000[[proxies]]name = \"test-tcp\"type = \"tcp\"localIP = \"127.0.0.1\"localPort = 22remotePort = 6000\nfrpc.service配置如下（权限要 chown 给root，并且 chmod 调整合适的权限，否则 enable 了依旧开机没反应，需要手动 restart）：\n12345678910111213[Unit]Description=frps (Fast Reverse Proxy Server)After=network.target[Service]Type=simpleUser=rootExecStart=/home/xmy/frp/frpc -c /home/xmy/frp/frpc.tomlRestart=on-failureLimitNOFILE=4096[Install]WantedBy=multi-user.target\n最后，输入以下指令，即可登录自己的电脑： ssh -o Port=6000 xmy@52.163.103.91\n由于 ssh 连自己后命令行与本地的命令行完全相同，一般可以靠延迟判断是自己还是分身。\n在阿里云那边认证通过，且配置过域名后，可以直接 ping 或者 dig 检验\n1234(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~$ ping xmy.zoneping: xmy.zone: 未知的名称或服务(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~$ ping xmy.zonePING xmy.zone (52.163.103.91) 56(84) bytes of data.\n12345678ssh xmy@xmy.zone   # 非法# 以下两者等价ssh xmy@52.163.103.91 -p 6000ssh xmy@xmy.zone -p 6000# 以下两者等价ssh azureuser@xmy.zonessh azureuser@xmy.zone -p 22\nStep 4：Nginx反向代理\nsudo nano /etc/nginx/sites-available/xmy.zone 后，在文件中输入：\n1234567891011server {    listen 80;    server_name xmy.zone;  # 配置您的域名    root /home/xmy/blog/public;  # Hexo 生成的静态文件所在的目录    index index.html index.htm;    location / {        try_files $uri $uri/ =404;    }}\nsudo nano /etc/nginx/nginx.conf 中第一行的user要改成root，这个非常重要且没有人说\n123sudo ln -s /etc/nginx/sites-available/xmy.zone /etc/nginx/sites-enabled/sudo nginx -t  # 检查配置是否正确sudo systemctl reload nginx  # 重新加载以应用配置\n修改frp配置，使其可以转发http请求\nfrps.toml：\n12345678bindPort = 7000vhostHTTPPort = 80  # 接收 HTTP 请求并将其转发到客户端vhostHTTPSPort = 443[webServer]   # dashboard最新版需要这么写port = 7500user = \"azureuser\"password = \"密码\"\nfrpc.toml\n12345678910111213141516serverAddr = \"xmy.zone\"serverPort = 7000[[proxies]]name = \"test-tcp\"type = \"tcp\"localIP = \"127.0.0.1\"localPort = 22remotePort = 6000[[proxies]]name = \"http-proxy\"type = \"http\"localIP = \"127.0.0.1\"localPort = 80customDomains = [\"xmy.zone\"]\n到这里就可以用 xmy.zone 打开博客了，如果需要检查中间哪部出了错可以采取下述步骤：\n如果没有跳出 Nginx 相关字样，或者 404、403，说明 frp 就出现了错误，可以通过 sudo systemctl status 检查，还不够就用 dashboard。\n重新配置完 frps 可以在 VSCode作端口映射后用本地 localhost 打开 dashboard\n这里碰到问题的话记得入站规则加上 7500 端口\n\n\n跳出来的话就说明 Nginx 配置出现问题，这个就比较便于检查了。\n总结\nssh\nssh 请求连接 xmy.zone 时，DNS解析到公网ip 52.163.103.91，它是我的 Azure 虚拟机，由于上面有 frps 服务，并且配置了 6000 端口监听，监听到连接请求后，会转发到 7000 端口与客户机的 22 端口通信（ 22 端口是 ssh ），所以 ssh -o Port=6000 xmy@52.163.103.91 就等于 ssh 客户机\n客户机与服务器通信同理，区别是 tcp client 不需要指定发送端口，所以任意端口出发，都能被服务器 7000 端口监听\nHTTP请求\n访问 xmy.zone 时，服务器监听 80 端口并转发到客户端，客户端有 Nginx 监听 80 端口，反向代理到本地 Hexo 生成静态文件所在目录，可以免去之前 hexo s 或 hexo d 的步骤\ndashboard\n配置了 7500 端口监听，通过 VSCode 端口映射到本地 7500 端口，即可直接打开\n自己对自己的Q&amp;A\nQ：为什么 ssh 服务，服务器的监听端口 6000 是在 frpc 配置的，而 http 请求的监听端口 80 就是在 frps 上配置？\nA：ssh 是 TCP 协议，无法共用一个端口。假设还要连MC，需要把服务器 65535 端口穿透到本地，那本地开放一个9000端口，肯定形如\nlocalPort = 9000 remotePort = 65535 。HTTP 之所以可以放在 frps 上是因为 HTTP 协议可以共用端口。\n","slug":"Azure上创建和使用虚拟机","date":"2025-03-02T06:17:37.000Z","categories_index":"","tags_index":"杂","author_index":"蜗角虚名羊"},{"id":"f6069ea1da3c4f73307d93ff3c0a4ad7","title":"微表面重建","content":"摸索\n这里是初始学长定的流程，但后来发现和实际情况相差很大，所有标定步骤都不用做了……权当记录一下。其实可以直接跳下一节。\n整体流程\n整个流程可以分为以下几个部分：\n\n\n在待测物体和校准使用的镜子上粘贴 ArUco 标记。\n\n\n图像采集（这部分通过另一个独立程序完成）。\n\n\n内参标定（Intrinsic Calibration）。\n\n\n几何标定（Geometric Calibration）。\n\n\n辐射标定（Radiometric Calibration）。\n\n\n表面法线计算（Surface Normal Calculation）。\n\n\n漫反射表面法线计算\n计算表面法线的代码异常简单，只需如下步骤：\n123self.diff_x = frames_x_n[..., 1] - frames_x_n[..., 0]self.diff_y = frames_y_n[..., 1] - frames_y_n[..., 0]z = np.sqrt(1 - np.square(self.diff_x) - np.square(self.diff_y))\n其中frames_x_n[..., 0]，frames_x_n[..., 1]是屏幕顺着方向分别从亮到暗和从暗到亮打光到物体表面后拍摄的两张图。\n看了SKINSCAN论文，研究了几天终于研究出来了（论文里就两行公式，包括条件，全得自己脑补）。\n提前说一下有两个条件要满足：\n\n屏幕正对物体\n假设屏幕与物体相比足够大\n\n回顾双向反射分布函数（BRDF），\n\n在这里，假设物体有朗伯反射特性，表面在所有方向上的辐射率都是均匀的，令\n\n则，\n\n其中：\n：屏幕上生成的光图案，作为入射光的分布。\n：定义表面材料的反射特性。\n：衡量材料对入射光的漫反射能力。\n：描述入射光的方向。\n：定义表面的法向量，影响光与表面交互的方向性。\n屏幕是个面光源，假设物体表面坐标  确定，其法向量为  ，对屏幕表面的每个点  积分，根据BRDF计算该点在两个场景中收到的辐射：\n\n\n由于屏幕正对物体，所以  和  点积一定大于  ，不用 ，忽略系数可以得到：\n\n公式有点丑，调整一下：\n\n此时发现，如果，则\n\n在屏幕足够大的情况下，可视为这种情况，故法向量在  方向上的值与  成正比。\n碰到的困难（随手记）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Q：8_11_checker.npz得想办法自己搞一个出来A：搞出来了以后发现并不需要，它mirror数据中确实是8*24的Q：imgDistortFilelist = readFileList(imgDistortFolder)竟然能出错A：断点定错了，是读该目录下文件出现的问题Q：h, w = imgDistort.shape[:2]，明明看图像明显可以看出宽&gt;高，但输出shape是2448，2048，高&gt;宽A：shape没问题，(6692, 7996, 3)，是我搞错了，shape属性和图像显示工具的宽高定义方式不同shape是(h,w,3)；图像显示工具是w*h；坐标轴是x为宽，y为高Q：高阶径向很大，导致结果很不理想[[-1.79807615e+00 -1.51664935e+00  2.15608648e-03  9.33400363e-04   2.45988598e+00 -1.72972173e+00 -1.76633092e+00  2.70524422e+00   0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00   0.00000000e+00  0.00000000e+00]]A：关闭原代码中的cv2.CALIB_RATIONAL_MODEL选项，重新运行，畸变系数如下[[-0.06838548  0.1297082   0.00215606  0.00093164 -0.10610527]]但结果还是不理想\\继续Q：fxfy对焦问题？cxcy图像中心？标定图像？A：我在计算相机内参时的图像分辨率为2448*2048像素，而需要反畸变的图像分辨率为7996*6992，我觉得这是反畸变失败的核心原因，焦距和光学中心在新的图上都失效了解决方案是缩放，终于得到正确结果了呜呜呜Q：geometric calibration检测不到checker board，代码都是原先的，似乎数据上有问题。到底是因为镜子尺寸不同，还是arucoBoardHeight= 0.2884, arucoBoardWidth= 0.5932有问题？half_length = 0.2000 - 0.005这部分肯定有问题，我肉眼几乎观察不到边框A：罪魁祸首img = (img/65535*255).astype(np.uint8)，搞得图全黑了Q：ARUCO_BOARD_HEIGHT = half_height * 2    ARUCO_BOARD_WIDTH = half_length * 2这两句，前面传入的half_height、half_length是镜子的一半高度和宽度，在这里变成了aruco board的高度和宽度，A：好吧一样，但是checker board的数据消失了Q：整张图绿油油的A：frame_markers = aruco.drawDetectedMarkers(img.copy(), corners, ids)输入BGR，返回BGR，但matplotlib用的是RGBQ：镜子放反了。相机内参是不能变动的，图像翻转180度可以视为世界翻转了180度，理论还是能继续实验，但还是不行A：相机内参也变了似乎Q：id为4的aruco标记左上角坐标为1885., 1270.，理论是正确的，但在图中发生偏移A1：reProjAruco中没用到检测的arucoA2：前面检测的aruco已经把位姿 (rvec, tvec)计算出了，通过位姿重投影，然后函数前面的默认值没有修改，导致投影错误Q：标记只能检测出4个，重投影计算正确，但后续工作无法继续进行A：换了张图ok了，可能光线强了点，这个要看运气Q：重影极其严重A1：畸变出了问题，flags=cv2.CALIB_FIX_K3忽略高阶径向畸变可以基本解决A2：基本可以视为没有问题了，因为普通镜头通常不会需要高阶修正。下次可以多拍几张图片，并且把镜子尽可能放正来减小切向畸变的影响。然后修改参数重新试一试Q：aruco的重投影啥的都没问题，但是z轴反了，才发现A：说是可以不用管Q：PMD的结果很奇怪A：得到相位图需要分别投射同一频率的多幅光栅图像至物体表面用以获得物体表面信息对应相位，一组图像之间有固定的相位差，这里没有这么做，也没有这个需求Q：calibration.npz和PhaseMapHV.npz的导出A：okQ：还是有重影A：通过比较反畸变后图片，认为径向畸变的量计算有误，标定板不光要各个角度，还要尽可能在屏幕边缘Q：could not broadcast input array from shape (4194304,) into shape (5013504,)A：原本代码的height和width有一些错误，参看前文宽和高\n年后工作\n过年一个多月放假，年前三四个月的所有工作似乎都只是在摸索。年后开了个会，大致定了做的内容，所以下面才是正题（还是好没底啊，真的能行吗）。\n其实我对法向图的生成就有些许怀疑，但论文和学长在人皮肤表面的实验放在这，也挺有说服力的，没有实质性证据的话也不要去猜疑了，好好完成任务。\n\n这里能感受出不是颜色影响，而是高度影响，相信！\nNEW整体流程\n\n利用拍的六张图重建表面法向图\n拼接局部图片为完整的图（相机分辨率有上限，实验表明需要离画近到一定程度才有效）\n用Frankot-Chellappa算法重建Mesh\n通过前面的结果（法向图和Mesh），自动分析笔触和推断画的破损情况（后认为手标+算法加强稍微有可行性一点）\n开发系统\n\n3.7小记\n3.5的会议给我安排了几个任务：\n\n之前有一个图重复拍5次取平均进行去噪，确实少了很多噪点，但同时抹平了很多信息，这次考虑方差大到一定程度取平均或者其他算法保留原本信息前提下尽可能去噪；\n下图分别是x和y方向的法向量，但似乎一个凹一个凸，判断xy哪个反了，修改代码；\n\n\n\n\n直接生成z方向的法向图；\n\n\n拼接原图和法向图。\n\n\n3.8小记\n上面几个任务都有问题\n\n\n虽然判断的方法很多，但处理的手段很单一，最多取平均、取中位数、随机……尝试后发现效果不佳。\n\n\nx和y方向的法向量并没有什么所谓的凹和凸，它只是微分后的结果，并没有实际意义，实际意义得生成深度图和mesh以后才能显现，可又碰到两个问题，一个是噪点太多生成不出细节，另一个是单位不对，z的计算前提是单位向量，但并不知道x,y变成单位向量需要乘什么系数。\n\n\n同2\n\n\nSuperGlue拼不出，也许是重合面积不够大；并且之前还发现过图片多显存会炸。再试试不用默认选项有什么效果。\n\n\n3.11小记\nTODO LIST：\n\n\n法向图左侧偏红，右侧偏蓝，这可能是导致深度图有弯折的重要原因，推测是光源非论文中的球体导致的，尝试通过法向图中加入高通滤波解决，再不行在frankot-chellappa中加。\n\n\n大图片无法生成法向图的问题暂时通过降低分辨率解决，并用blender打开便于观察。用pil的bilinear interpolation\n\n\nxy方向matplotlib热力图，推测x和y方向的视错觉问题成因\n\n\n稳定图像拼接结果\n\n\n说明文档\n\n\n3.15小记\n主要记录3.14会议内容和3.15工作内容\n\n\n高通滤波试过不可以，试试频谱图分析后带通滤波\n\n\n原图已经都可以匹配了，可试着通过原图的匹配点匹配法向量图，或改变blending strategy\n\n\n深度图降采样后可以完整生成了，并且只要一分钟，弯折程度很厉害，就看1解决情况\n\n\nxy方向matplotlib热力图，推测x和y方向的视错觉问题成因\n\n\n图片不需要管cv2是BGR读进来的，因为一律转成了灰度，之后都以RGB在操作，输出时要注意转化成BGR\n3.23小记\n记录3.19会议内容和后几天的工作\n\n\nstitching（分步已用开源库解决，但效果略差于cv的stitcher，需要更大重合面积）\n\n\n整体颜色(127,127,255)\n\n\n简化mesh\n\n\nmatlab分析频谱（个人觉得意义不大，先放最后）\n\n\n3.29小记\n记录3.26会议内容和后几天的工作\n\n\nopencv图像大小限制会导致生成的生成的全景图偏小（imwrite为jpg大小损失了，ok）\n\n\n继续简化mesh（还没简化已经从243MB-&gt;178MB，合并了重复点，导出速度从半分钟到了一秒，不懂为啥这么快，法向量信息消失但反而更易于观察了）\n\n\n整理结果，包括错误结果\n\n\n完成所有任务后可以封装一下api\n\n\n代码注释、规范和README\n\n\n3.31小记\n记录3.30会议和实验内容和后几天工作\n\n\n深度图太凹（）\n\n\n拼接完特征消失（调整参数，但要牺牲拼接的流畅度）\n\n\ncase by case（取局部30*30个点的中位数计算参数）\n\n\n纹理，RGB2BGR（好解决）\n\n\n4.3小记\n记录4.2会议内容和后几天工作\n\n\n图片pattern顺序（这次由于屏幕上方对应画下方，所以y方向反了，ok）\n\n\n法向量降采样问题（Stitching可以不降采样，可以生成深度图前降采样，ok，荷花太长了不能拼接）\n\n\n深度图简化（可以没有纹理）\n\n\n深度图太凹（变好了，不知道算不算解决，ok一半）\n\n\n颜色深浅的影响（不出意外是有的）\n\n\n法向图加强手段（暂时没时间做，而且感觉没有意义，宇宸那边本来就要做）\n\n\n降采样对原始数据影响大小（4影响不大，6影响就大了，暂定4）\n\n\n网格简化：从开始obj的290M到ply90M，到简化后5M，我没想到效果这么好，明显比通过降采样到83M的obj清楚\n5.20最新状态\n已在 CAD/Graphics 投出，期待审稿通过。\n","slug":"微表面重建","date":"2024-12-19T07:01:21.000Z","categories_index":"","tags_index":"三维重建","author_index":"蜗角虚名羊"},{"id":"9e3d7c5384da01cbabfcc080789e0f92","title":"min25筛","content":"前面部分引用自OI wiki\n定义\n从此种筛法的思想方法来说，其又被称为「Extended Eratosthenes Sieve」。\n由于其由 Min_25 发明并最早开始使用，故称「Min_25 筛」。\n性质\n其可以在  或  的时间复杂度下解决一类 积性函数 的前缀和问题。\n要求： 是一个关于  可以快速求值的完全积性函数之和（例如多项式）； 可以快速求值。\n记号\n\n如无特别说明，本节中所有记为  的变量的取值集合均为全体质数。\n\n，即  为质数时其值为 ，否则为 。\n：全体质数中第  小的质数（如：）。特别地，令 。\n，即  的最小质因数。特别地， 时，其值为 。\n\n\n\n解释\n观察  的定义，可以发现答案即为 。\n\n考虑如何求出 。通过枚举每个  的最小质因子及其次数可以得到递推式：\n\n最后一步推导基于这样一个事实：对于满足  的 ，有 ，故 。\n其边界值即为 。\n假设现在已经求出了所有的 ，那么有两种方式可以求出所有的 ：\n\n直接按照递推式计算。\n从大到小枚举  转移，仅当  时转移增加值不为零，故按照递推式后缀和优化即可。\n\n\n现在考虑如何计算 。\n观察求  的过程，容易发现  有且仅有  这  处的点值是有用的。\n一般情况下， 是一个关于  的低次多项式，可以表示为 。\n那么对于每个 ，其对  的贡献即为 。\n分开考虑每个  的贡献，问题就转变为了：给定 ，对所有的 ，求 。\n\n\n\n\n\n\n\n\n\nNotice： 是完全积性函数！\n于是设 ，即埃筛第  轮筛完后剩下的数的  值之和。\n对于一个合数 ，必定有 。设  为不大于  的最大质数，则 ，即在埃筛进行  轮之后剩下的均为质数。\n考虑  的边界值，显然为 。（还记得吗？特别约定了 ）\n对于转移，考虑埃筛的过程，分开讨论每部分的贡献，有：\n\n对于  的部分， 值不变，即 。\n对于  的部分，被筛掉的数必有质因子 ，即 。\n对于第二部分，由于 ，满足  的  会被额外减去。这部分应当加回来，即 。\n\n则有：\n\n\n复杂度分析\n对于  的计算，其第一种方法的时间复杂度被证明为 （见 zzt 集训队论文 2.3）；\n对于第二种方法，其本质即为洲阁筛的第二部分，在洲阁论文中也有提及（6.5.4），其时间复杂度被证明为 。\n对于  的计算，事实上，其实现与洲阁筛第一部分是相同的。\n考虑对于每个 ，只有在枚举满足  的  转移时会对时间复杂度产生贡献，则时间复杂度可估计为：\n\n对于空间复杂度，可以发现不论是  还是 ，其均只在  处取有效点值，共  个，仅记录有效值即可将空间复杂度优化至 。\n首先，通过一次数论分块可以得到所有的有效值，用一个大小为  的数组  记录。对于有效值 ，记  为  在  中的下标，易得：对于所有有效值 ，。\n然后分开考虑小于等于  的有效值和大于  的有效值：对于小于等于  的有效值 ，用一个数组  记录其 ，即 ；对于大于  的有效值 ，用一个数组  记录 ，由于  过大所以借助  记录 ，即 。\n这样，就可以使用两个大小为  的数组记录所有有效值的  并  查询。在计算  或  时，使用有效值的  代替有效值作为下标，即可将空间复杂度优化至 。\n过程\n对于  的计算，我们实现时一般选择实现难度较低的第一种方法，其在数据规模较小时往往比第二种方法的表现要好；\n对于  的计算，直接按递推式实现即可。\n对于 ，可以用线性筛预处理出  来替代  递推式中的 。\n相应地， 递推式中的  也可以用此方法预处理。\n用 Extended Eratosthenes Sieve 求 积性函数   的前缀和时，应当明确以下几点：\n\n如何快速（一般是线性时间复杂度）筛出前  个  值；\n 的多项式表示；\n如何快速求出 。\n\n明确上述几点之后按顺序实现以下几部分即可：\n\n筛出  内的质数与前  个  值；\n对  多项式表示中的每一项筛出对应的 ，合并得到  的所有  个有用点值；\n按照  的递推式实现递归，求出 。\n\n例题\n求莫比乌斯函数的前缀和\n求 。\n易知 。则 。\n直接筛即可得到  的所有  个所需点值。\n求欧拉函数的前缀和\n求 。\n首先易知 。\n对于  的一次项 ，有 ；\n对于  的常数项 ，有 。\n筛两次加起来即可得到  的所有  个所需点值。\n「LOJ #6053」简单的函数\n给定 ：\n\n易知 。则按照筛  的方法筛，对  讨论一下即可。\n此处给出一种 C++ 实现（也是我的min25筛模板）：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* 「LOJ #6053」简单的函数 */#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxs = 200000, mod = 1000000007, inv2 = (mod+1)&gt;&gt;1;  // 2sqrt(n)int pri[maxs / 7], lpf[maxs + 1], spri[maxs + 1], pcnt, lim, G[maxs + 1][2], Fprime[maxs + 1], cnt;ll lis[maxs + 1], global_n;#define sqr(x) (1ll*(x)*(x))#define idx(v) (v &lt;= lim ? le[v] : ge[global_n / v])  // n/i的值为v时，i在数论分块中是第几块 int le[maxs + 1],  // x &lt;= \\sqrt{n}\tge[maxs + 1];  // x &gt; \\sqrt{n}\tint sum(int x,int y){x+=y;if(x&gt;=mod)x-=mod;return x;}int sub(int x,int y){x-=y;if(x&lt;0)x+=mod;return x;}void inc(int &amp;x,int y){x+=y;if(x&gt;=mod)x-=mod;}void dec(int &amp;x,int y){x-=y;if(x&lt;0)x+=mod;}void sieve(int n) {\tfor (int i = 2; i &lt;= n; ++i) {\t\tif (lpf[i] == 0) {  // 记录质数\t\t\tlpf[i] = ++pcnt; // i的最小质因数编号 \t\t\tpri[lpf[i]] = i; // 第i个质数 \t\t\tspri[pcnt] = sum(spri[pcnt - 1], i);  // 前缀和\t\t}\t\tfor (int j = 1, v; j &lt;= lpf[i] &amp;&amp; (v = i * pri[j]) &lt;= n; ++j) lpf[v] = j;\t}}void init(ll n) {\tfor (ll i = 1, j, v; i &lt;= n; i = n / j + 1) {\t\tj = n / i;\t\tv = j % mod;\t\tlis[++cnt] = j;\t\tidx(j) = cnt;\t\tG[cnt][0] = sub(v, 1ll); // \\sum_2^v i^0\t\tG[cnt][1] = 1ll * (v + 2ll) * (v - 1ll) % mod * inv2 % mod; // \\sum_2^v i^1\t}}void calcFprime() {//求Fprime\tfor (int k = 1; k &lt;= pcnt; ++k) {\t\tint p = pri[k];\t\tll sqrp = sqr(p);\t\tfor (int i = 1; lis[i] &gt;= sqrp; ++i) {\t\t\tll v = lis[i] / p;\t\t\tint id = idx(v);\t\t\tdec(G[i][0], sub(G[id][0], k - 1));\t\t\tdec(G[i][1], 1ll* p * sub(G[id][1], spri[k - 1]) % mod); // g(p_k)=p, G_{k-1}(p_{k-1})=sum_pri\t\t}\t}\t/* F_prime = G_1 - G_0 */\tfor (int i = 1; i &lt;= cnt; ++i) Fprime[i] = sub(G[i][1], G[i][0]); // F(p)=p-1}int f_p(int p, int c) {\t/* f(p^{c}) = p xor c */\treturn p xor c;}int F(int k, ll n) {//已知Fprime求F\tif (n &lt; pri[k] || n &lt;= 1) return 0;\tint id = idx(n);\tll ans = Fprime[id] - (spri[k - 1] - (k - 1)); // Fprime(n)-Fprime(p_{k-1})\tif (k == 1) ans += 2;\tfor (int i = k; i &lt;= pcnt &amp;&amp; sqr(pri[i]) &lt;= n; ++i) {\t\tll pw = pri[i], pw2 = sqr(pw);\t\tfor (int c = 1; pw2 &lt;= n; ++c, pw = pw2, pw2 *= pri[i])\t\t\tans += (1ll * f_p(pri[i], c) * F(i + 1, n / pw) + f_p(pri[i], c + 1)) % mod;\t}\treturn ans % mod;}int main() {\tscanf(\"%lld\", &amp;global_n);\tlim = sqrt(global_n);  // 上限\tsieve(lim + 1000);  // 预处理\tinit(global_n);\tcalcFprime();\tprintf(\"%lld\\n\", (F(1, global_n) + 1ll + mod) % mod); // F(1)单独加上 }\nICPC2024昆明 F. Flowers\n转化后题意：给定，求，其中  为  不同质因子个数\n方法1（min25+拉插+CRT，麻烦）：\n令 ，则  为积性函数。\n由于  的值不会超过  ，故枚举  ，依次求出 。\n 可表示为 ，通过拉格朗日插值求出  后，即可求出答案：\n，通过这个式子也可以发现不需要求。\n因为拉格朗日插值中会遇到很大的数，所以需要对两个大质数分别取模后CRT合并。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;bits/stdc++.h&gt;using namespace std;#define pb push_back#define int long longconst int maxs = 200000,M1=998244353,M2=1e9+7;int pri[maxs / 7], lpf[maxs + 1], spri[maxs + 1], pcnt;void sieve(const int &amp;n) {      for (int i = 2; i &lt;= n; ++i) {        if (lpf[i] == 0) {  // 记录质数          lpf[i] = ++pcnt;          pri[lpf[i]] = i;          spri[pcnt] = spri[pcnt - 1]+i;  // 前缀和        }        for (int j = 1, v; j &lt;= lpf[i] &amp;&amp; (v = i * pri[j]) &lt;= n; ++j) lpf[v] = j;      }}long long global_n;int lim;int le[maxs + 1],  // x &lt;= \\sqrt{n}    ge[maxs + 1];  // x &gt; \\sqrt{n}#define idx(v) (v &lt;= lim ? le[v] : ge[global_n / v])int G[maxs + 1][2], Fprime[maxs + 1];long long lis[maxs + 1];int cnt;void init(const long long &amp;n,int x) {      for (long long i = 1, j, v; i &lt;= n; i = n / j + 1) {        j = n / i;        v = j;        lis[++cnt] = j;        (j &lt;= lim ? le[j] : ge[global_n / j]) = cnt;\t\tG[cnt][0]=(v-1)*x;//tip1      }}void calcFprime(int x) {      for (int k = 1; k &lt;= pcnt; ++k) {        const int p = pri[k];        const long long sqrp = p*p;        for (int i = 1; lis[i] &gt;= sqrp; ++i) {          const long long v = lis[i] / p;          const int id = idx(v);            G[i][0]-=G[id][0]-(k-1)*x;//tip2        }      }      for (int i = 1; i &lt;= cnt; ++i) Fprime[i] = G[i][0];//tip3}int f_p(const int &amp;p, const int &amp;c,int x) {        return x;}int F(const int &amp;k, const long long &amp;n,int x) {      if (n &lt; pri[k] || n &lt;= 1) return 0;      const int id = idx(n);      long long ans = Fprime[id] - (k-1)*x;//tip4      for (int i = k; i &lt;= pcnt &amp;&amp; pri[i]*pri[i] &lt;= n; ++i) {        long long pw = pri[i], pw2 =pw*pw;        for (int c = 1; pw2 &lt;= n; ++c, pw = pw2, pw2 *= pri[i])          ans +=          ((long long)f_p(pri[i], c,x) * F(i + 1, n / pw,x) + f_p(pri[i], c + 1,x));      }  return ans;}int mod;int inv(int k,int MOD) {  int res = 1;  for (int e = MOD - 2; e; e /= 2) {    if (e &amp; 1) res = res * k % MOD;    k = k * k % MOD;  }  return res;}int Pw(int k,int y,int MOD) {  int res = 1;  for (int e = y; e; e /= 2) {    if (e &amp; 1) res = res * k % MOD;    k = k * k % MOD;  }  return res;}std::vector&lt;int&gt; lagrange_interpolation(const std::vector&lt;int&gt; &amp;x,                                        const std::vector&lt;int&gt; &amp;y,int MOD) {  const int n = x.size();  std::vector&lt;int&gt; M(n + 1), xx(n), f(n);  M[0] = 1;  for (int i = 0; i &lt; n; ++i) {    for (int j = i; j &gt;= 0; --j) {      M[j + 1] = (M[j] + M[j + 1]) % MOD;      M[j] = M[j] * (MOD - x[i]) % MOD;    }  }  for (int i = n - 1; i &gt;= 0; --i) {    for (int j = 0; j &lt; n; ++j) {      xx[j] = (xx[j] * x[j] + M[i + 1] * (i + 1)) % MOD;    }  }  for (int i = 0; i &lt; n; ++i) {    int t = y[i]%MOD * inv(xx[i],MOD) % MOD, k = M[n];    for (int j = n - 1; j &gt;= 0; --j) {      f[j] = (f[j] + k * t) % MOD;      k = (M[j] + k * x[i]) % MOD;    }  }  return f;}void exgcd(int a, int b, int&amp; x, int&amp; y) {      if (b == 0) {            x = 1, y = 0;            return;      }      exgcd(b, a % b, y, x);      y -= a / b * x;}signed main() {      scanf(\"%lld%lld\", &amp;global_n,&amp;mod);      lim = sqrt(global_n);  // 上限      sieve(lim + 1000);  // 预处理      vector&lt;int&gt;A,B;      A.pb(0),B.pb(0);      A.pb(1),B.pb(global_n);      for (int x=2;x&lt;=10;x++){            cnt=0;            init(global_n,x);            calcFprime(x);            B.pb(F(1, global_n,x) + x);            A.pb(x);        }        auto f1 = lagrange_interpolation(A,B,M1);        auto f2 = lagrange_interpolation(A,B,M2);        vector&lt;int&gt;f;        int M=M1*M2;        for (int i=0;i&lt;f1.size();i++){\t\t\tint b,y;            exgcd(M2, M1, b, y);            int tmp=(__int128)f1[i]*M2*b%M;//处理爆long long             exgcd(M1, M2, b, y);            tmp=((tmp+(__int128)f2[i]*M1*b)%M+M)%M;//模完才是算好的值，才能模mod-1             f.pb(tmp);        }        int ans=1;        for (int i=2;i&lt;f.size();i++) ans=(ans*Pw(A[i],f[i],mod))%mod;        cout&lt;&lt;ans&lt;&lt;endl;}\n方法2（需充分理解min25，巧妙）：\n观察转移 \n发现包含质数的个数已经在转移里一目了然了\n 对应：\n1ans[w + 1] += Fprime[id] - (k - 1);\n 对应：\n12ans[w + 1]++;F(i + 1, n / pw, w + 1);\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxs = 200000, mod = 1000000007, inv2 = (mod+1)&gt;&gt;1;  // 2sqrt(n)int pri[maxs / 7], lpf[maxs + 1], spri[maxs + 1], pcnt, lim, G[maxs + 1][2], Fprime[maxs + 1], cnt;ll lis[maxs + 1], global_n;ll ans[99];#define sqr(x) (1ll*(x)*(x))#define idx(v) (v &lt;= lim ? le[v] : ge[global_n / v])  // n/i的值为v时，i在数论分块中是第几块 int le[maxs + 1],  // x &lt;= \\sqrt{n}\tge[maxs + 1];  // x &gt; \\sqrt{n}\tint sum(int x,int y){x+=y;if(x&gt;=mod)x-=mod;return x;}int sub(int x,int y){x-=y;if(x&lt;0)x+=mod;return x;}void inc(int &amp;x,int y){x+=y;if(x&gt;=mod)x-=mod;}void dec(int &amp;x,int y){x-=y;if(x&lt;0)x+=mod;}void sieve(int n) {\tfor (int i = 2; i &lt;= n; ++i) {\t\tif (lpf[i] == 0) {  // 记录质数\t\t\tlpf[i] = ++pcnt; // i的最小质因数编号 \t\t\tpri[lpf[i]] = i; // 第i个质数 \t\t\tspri[pcnt] = sum(spri[pcnt - 1], i);  // 前缀和\t\t}\t\tfor (int j = 1, v; j &lt;= lpf[i] &amp;&amp; (v = i * pri[j]) &lt;= n; ++j) lpf[v] = j;\t}}void init(ll n) {\tfor (ll i = 1, j, v; i &lt;= n; i = n / j + 1) {\t\tj = n / i;\t\tv = j % mod;\t\tlis[++cnt] = j;\t\tidx(j) = cnt;\t\tG[cnt][0] = sub(v, 1ll); // \\sum_2^v i^0\t}}void calcFprime() {//求Fprime\tfor (int k = 1; k &lt;= pcnt; ++k) {\t\tint p = pri[k];\t\tll sqrp = sqr(p);\t\tfor (int i = 1; lis[i] &gt;= sqrp; ++i) {\t\t\tll v = lis[i] / p;\t\t\tint id = idx(v);\t\t\tdec(G[i][0], sub(G[id][0], k - 1));\t\t}\t}\tfor (int i = 1; i &lt;= cnt; ++i) Fprime[i] = G[i][0];}void F(int k, ll n, int w) {//已知Fprime求F\tif (n &lt; pri[k] || n &lt;= 1) return;\tint id = idx(n);\tans[w + 1] += Fprime[id] - (k - 1);\tfor (int i = k; i &lt;= pcnt &amp;&amp; sqr(pri[i]) &lt;= n; ++i) {\t\tll pw = pri[i], pw2 = sqr(pw);\t\tfor (int c = 1; pw2 &lt;= n; ++c, pw = pw2, pw2 *= pri[i]){\t\t\tans[w + 1]++;\t\t\tF(i + 1, n / pw, w + 1);\t\t}//\t\t\tans += (1ll * f_p(pri[i], c) * F(i + 1, n / pw) + f_p(pri[i], c + 1)) % mod;\t}}int M;int pw(int x, ll y, int M){\tint z = 1;\tfor (; y; y &gt;&gt;= 1, x = 1ll * x * x % M)\t\tif (y &amp; 1) z = 1ll * z * x % M;\treturn z;}int main() {\tscanf(\"%lld%d\", &amp;global_n, &amp;M);\tlim = sqrt(global_n);  // 上限\tsieve(lim + 1000);  // 预处理\tinit(global_n);\tcalcFprime();\tF(1, global_n, 0);\tint pi = 1;\tfor (int i = 2; i &lt;= 10; i++) pi = 1ll * pi * pw(i, ans[i], M) % M;\tcout &lt;&lt; pi &lt;&lt; '\\n';}\na*b problem（我出的题）\n题意： 且  ，求有序数对  数量，答案对1e9+7取模\n令表示 且  数对数量，，则答案为\n等价于每个质因子在中次数的最小值都是  ，易知各个质因子之间独立，为积性函数，问题在于怎么求\n方法1（我的，背包+dfs+组合数+min25）\n时，等价于将划分给个数，第  个数必须是  的倍数，且个数里至少有一个为的方案数\n用至多不超过的时间 （， 中c的取值小于等于33）预处理，可以得出结果\n时，，其中是中1的数量，p只有1次，只能是1的倍数\n此时发现为关于的零次多项式，可快速求，故答案可用min25筛快速求得\n时间复杂度，此时在情况下都没有问题，更大的时候复杂度瓶颈的  需要优化\n考虑枚举某个集合的元素均为0，剩余部分形如 （）\n如果已知  在每个c处的方案数，那么可以的时间内推出在每个c处的方案数\n发现对于值相同的，性质是一样的，可以直接用这个值有几个来代替，不需要枚举，加上一些剪枝，可以通过的数据\n我的代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxs = 200000,mod = 1e9+7,maxc=33,maxk=1e5+5;void inc(int &amp;x, int y) {\tx += y;\t(mod &lt;= x) &amp;&amp; (x -= mod);}void dec(int &amp;x, int y) {\tx -= y;\t(x &lt; 0) &amp;&amp; (x += mod);}int sub(int x, int y) {\treturn x &lt; y ? x - y + mod : (x - y);}int div2(int x) {\treturn ((x &amp; 1) ? x + mod : x) &gt;&gt; 1;}ll sqrll(int x){return 1ll*x*x;}int pw(int x,int y){int z=1;for(;y;y&gt;&gt;=1,x=1ll*x*x%mod)if(y&amp;1)z=1ll*z*x%mod;return z;}int pri[maxs / 7], lpf[maxs + 1], pcnt;void sieve(const int &amp;n) {\tfor (int i = 2; i &lt;= n; ++i) {\t\tif (lpf[i] == 0) {\t// 记录质数\t\t\tlpf[i] = ++pcnt;\t\t\tpri[lpf[i]] = i;\t\t}\t\tfor (int j = 1, v; j &lt;= lpf[i] &amp;&amp; (v = i * pri[j]) &lt;= n; ++j) lpf[v] = j;\t}}typedef vector&lt;int&gt; V;map&lt;V,int&gt;mp;queue&lt;V&gt;q;const int TMP=400000;//上限239496 int fun[TMP][maxc+3];//fun[i][j]，id为i的表达式和为j的方案数，如2x+2y+3z=10 int sum[TMP];//sum为表达式左边有几个数，必须小于Kint Sum[TMP];//Sum为当前所有数的和，必须&lt;=maxc int f[maxc+3];//F[c]表示f(p^c)的答案 ll global_n;int lim;int le[maxs + 1],\t// x &lt;= \\sqrt{n}\t\tge[maxs + 1];\t// x &gt; \\sqrt{n}#define idx(v) (v &lt;= lim ? le[v] : ge[global_n / v])V num(maxc+1);int G[maxs + 1], Fprime[maxs + 1],fac[maxk],ifac[maxk];ll lis[maxs + 1];int cnt;int K,t[102];void init(ll n) {\tfor (ll i = 1, j, v; i &lt;= n; i = n / j + 1) {\t\tj = n / i;\t\tv = j % mod;\t\tlis[++cnt] = j;\t\t(j &lt;= lim ? le[j] : ge[global_n / j]) = cnt;\t\tG[cnt]=sub(v, 1ll);\t}}void calcFprime() {\tfor (int k = 1; k &lt;= pcnt; ++k) {\t\tint p = pri[k];\t\tll sqrp = sqrll(p);\t\tfor (int i = 1; lis[i] &gt;= sqrp; ++i) {\t\t\tll v = lis[i] / p;\t\t\tint id = idx(v);\t\t\tdec(G[i], sub(G[id], (k - 1)));\t\t}\t}\tfor (int i = 1; i &lt;= cnt; ++i) Fprime[i]=G[i]*num[1];}int tot;void bfs(){\tV u(maxc+1);\tmp[u]=++tot;\tsum[1]=0;\tSum[1]=0;\tfun[1][0]=1;\tq.push(u);\twhile (!q.empty()){\t\tu=q.front(),q.pop();\t\tint id=mp[u];\t\tif (sum[id]+1==K) break;\t\tfor (int i=1;i&lt;=maxc &amp;&amp; Sum[id]+i&lt;=maxc;i++)\t\t\tif (u[i]&lt;num[i]){\t\t\t\tu[i]++;\t\t\t\tif (!mp.count(u)){\t\t\t\t\tmp[u]=++tot;\t\t\t\t\tsum[tot]=sum[id]+1;\t\t\t\t\tSum[tot]=Sum[id]+i;\t\t\t\t\tfor (int j=i;j&lt;=maxc;j++)\t\t\t\t\t\tfun[tot][j]=(fun[id][j-i]+fun[tot][j-i])%mod;//\t\t\t\t\tfor (int j=0;j&lt;=maxc;j++)//\t\t\t\t\t\tfor (int k=1;k*i&lt;=j;k++) inc(fun[tot][j],fun[id][j-k*i]);\t\t\t\t\tint tmp=1;\t\t\t\t\tfor (int j=1;j&lt;=maxc;j++) tmp=1ll*tmp*fac[num[j]]%mod*ifac[u[j]]%mod*ifac[num[j]-u[j]]%mod;\t\t\t\t\tfor (int j=0;j&lt;=maxc;j++)\t\t\t\t\t\tinc(f[j],1ll*fun[tot][j]*tmp%mod);\t\t\t\t\tq.push(u);\t\t\t\t}\t\t\t\tu[i]--;\t\t\t}\t}}int f_p(int p, int c) {return f[c];}int F(const int &amp;k, const long long &amp;n) {\tif (n &lt; pri[k] || n &lt;= 1) return 0;\tint id = idx(n);\tll ans = Fprime[id] - (k-1)*num[1];\t\tfor (int i = k; i &lt;= pcnt &amp;&amp; sqrll(pri[i]) &lt;= n; ++i) {\t\tll pw = pri[i], pw2 = sqrll(pw);\t\tfor (int c = 1; pw2 &lt;= n; ++c, pw = pw2, pw2 *= pri[i])\t\t\tans +=(1ll*f_p(pri[i], c) * F(i + 1, n / pw) + f_p(pri[i], c + 1)) % mod;\t}\treturn ans % mod;}int main() {\tscanf(\"%lld%d\", &amp;global_n,&amp;K);\tfac[0]=1;\tfor (int i=1;i&lt;=K;i++) fac[i]=1ll*fac[i-1]*i%mod;\tifac[K]=pw(fac[K],mod-2);\tfor (int i=K;i;i--) ifac[i-1]=1ll*ifac[i]*i%mod;\tfor (int i=1;i&lt;=K;i++) scanf(\"%d\",&amp;t[i]),num[t[i]]++;\tbfs();\tlim = sqrt(global_n);\t// 上限\tsieve(lim + 1000);\t// 预处理\tinit(global_n);\tcalcFprime();\tprintf(\"%lld\\n\", (F(1, global_n) + 1ll + mod) % mod);}\n方法2（更优秀，背包+组合数+min25）\n由前文可知，关键在于预处理 。等价于将划分给个数，\n第  个数必须是  的倍数，且个数里至少有一个为  的方案数。\n事实上，计算所有方案减去  个数都不是  的方案即可。\njiangly代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305#include &lt;bits/stdc++.h&gt;using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;// TODO: Dynamic ModInttemplate&lt;typename T&gt;constexpr T power(T a, u64 b) {    T res {1};    for (; b != 0; b /= 2, a *= a) {        if (b % 2 == 1) {            res *= a;        }    }    return res;}template&lt;u32 P&gt;constexpr u32 mulMod(u32 a, u32 b) {    return 1ULL * a * b % P;}template&lt;u64 P&gt;constexpr u64 mulMod(u64 a, u64 b) {    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;    res %= P;    return res;}template&lt;typename U, U P&gt;requires std::unsigned_integral&lt;U&gt;struct ModIntBase {public:    constexpr ModIntBase() : x {0} {}        template&lt;typename T&gt;    requires std::integral&lt;T&gt;    constexpr ModIntBase(T x_) : x {norm(x_ % T {P})} {}        constexpr static U norm(U x) {        if ((x &gt;&gt; (8 * sizeof(U) - 1) &amp; 1) == 1) {            x += P;        }        if (x &gt;= P) {            x -= P;        }        return x;    }        constexpr U val() const {        return x;    }        constexpr ModIntBase operator-() const {        ModIntBase res;        res.x = norm(P - x);        return res;    }        constexpr ModIntBase inv() const {        return power(*this, P - 2);    }        constexpr ModIntBase &amp;operator*=(const ModIntBase &amp;rhs) &amp; {        x = mulMod&lt;P&gt;(x, rhs.val());        return *this;    }        constexpr ModIntBase &amp;operator+=(const ModIntBase &amp;rhs) &amp; {        x = norm(x + rhs.x);        return *this;    }        constexpr ModIntBase &amp;operator-=(const ModIntBase &amp;rhs) &amp; {        x = norm(x - rhs.x);        return *this;    }        constexpr ModIntBase &amp;operator/=(const ModIntBase &amp;rhs) &amp; {        return *this *= rhs.inv();    }        friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &amp;rhs) {        lhs *= rhs;        return lhs;    }        friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &amp;rhs) {        lhs += rhs;        return lhs;    }        friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &amp;rhs) {        lhs -= rhs;        return lhs;    }        friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &amp;rhs) {        lhs /= rhs;        return lhs;    }        friend constexpr std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const ModIntBase &amp;a) {        return os &lt;&lt; a.val();    }        friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() == rhs.val();    }        friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() != rhs.val();    }        friend constexpr bool operator&lt;(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() &lt; rhs.val();    }    private:    U x;};template&lt;u32 P&gt;using ModInt = ModIntBase&lt;u32, P&gt;;template&lt;u64 P&gt;using ModInt64 = ModIntBase&lt;u64, P&gt;;constexpr u32 P = 1000000007;using Z = ModInt&lt;P&gt;;constexpr int K = 33;struct Comb {    int n;    std::vector&lt;Z&gt; _fac;    std::vector&lt;Z&gt; _invfac;    std::vector&lt;Z&gt; _inv;        Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}    Comb(int n) : Comb() {        init(n);    }        void init(int m) {        m = std::min&lt;i64&gt;(m, P - 1);        if (m &lt;= n) return;        _fac.resize(m + 1);        _invfac.resize(m + 1);        _inv.resize(m + 1);                for (int i = n + 1; i &lt;= m; i++) {            _fac[i] = _fac[i - 1] * i;        }        _invfac[m] = _fac[m].inv();        for (int i = m; i &gt; n; i--) {            _invfac[i - 1] = _invfac[i] * i;            _inv[i] = _invfac[i] * _fac[i - 1];        }        n = m;    }        Z fac(int m) {        if (m &gt; n) init(2 * m);        return _fac[m];    }    Z invfac(int m) {        if (m &gt; n) init(2 * m);        return _invfac[m];    }    Z inv(int m) {        if (m &gt; n) init(2 * m);        return _inv[m];    }    Z binom(int n, int m) {        if (n &lt; m || m &lt; 0) return 0;        return fac(n) * invfac(m) * invfac(n - m);    }} comb;std::vector&lt;int&gt; minp, primes;void sieve(int n) {    minp.assign(n + 1, 0);    primes.clear();        for (int i = 2; i &lt;= n; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }                for (auto p : primes) {            if (i * p &gt; n) {                break;            }            minp[i * p] = p;            if (p == minp[i]) {                break;            }        }    }}void solve() {    i64 n;    int k;    std::cin &gt;&gt; n &gt;&gt; k;        std::vector&lt;int&gt; cnt(K + 1);    for (int i = 0; i &lt; k; i++) {        int t;        std::cin &gt;&gt; t;        cnt[t]++;    }        std::vector&lt;Z&gt; dp(K + 1), dp2(K + 1);    dp[0] = 1;    dp2[0] = 1;    for (int i = 1; i &lt;= K; i++) {        if (cnt[i] == 0) {            continue;        }        for (int s = K; s &gt;= 0; s--) {            for (int j = 1; s + j * i &lt;= K; j++) {                Z w = comb.binom(j - 1 + cnt[i], cnt[i] - 1);                dp[s + j * i] += dp[s] * w;                w = comb.binom(j - 1, cnt[i] - 1);                dp2[s + j * i] += dp2[s] * w;            }            dp2[s] = 0;        }    }    for (int i = 0; i &lt;= K; i++) {        dp[i] -= dp2[i];        // std::cerr &lt;&lt; dp[i] &lt;&lt; \" \\n\"[i == K];    }        const int sqrtn = std::sqrt(n);    std::vector&lt;i64&gt; v;    for (int i = 1; i &lt;= sqrtn; i++) {        v.push_back(n / i);    }    for (int i = n / sqrtn - 1; i &gt;= 1; i--) {        v.push_back(i);    }        const int m = v.size();        auto idx = [&amp;](i64 x) {        if (x &lt;= sqrtn) {            return m - x;        } else {            return n / x - 1;        }    };        std::vector&lt;Z&gt; f(m);    for (int i = 0; i &lt; m; i++) {        f[i] = dp[1] * (v[i] - 1);    }        for (int i = 0; i &lt; primes.size(); i++) {        if (1LL * primes[i] * primes[i] &gt; n) {            break;        }        for (int j = 0; j &lt; m &amp;&amp; v[j] &gt;= 1LL * primes[i] * primes[i]; j++) {            Z w = f[idx(v[j] / primes[i])] - i * dp[1];            f[j] -= w;        }    }    for (int i = primes.size() - 1; i &gt;= 0; i--) {        if (1LL * primes[i] * primes[i] &gt; n) {            continue;        }        for (int j = 0; j &lt; m &amp;&amp; v[j] &gt;= 1LL * primes[i] * primes[i]; j++) {            int t = 1;            i64 c = v[j] / primes[i];            while (c &gt;= primes[i]) {                f[j] += (f[idx(c)] - (i + 1) * dp[1]) * dp[t] + dp[t + 1];                t++;                c /= primes[i];            }        }    }    std::cout &lt;&lt; f[0] + 1 &lt;&lt; \"\\n\";}int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        sieve(1E6);        int T;    std::cin &gt;&gt; T;        while (T--) {        solve();    }        return 0;}\n","slug":"min25","date":"2024-12-19T05:33:54.000Z","categories_index":"","tags_index":"acm,数学","author_index":"蜗角虚名羊"},{"id":"a43501af752cd97a928bbdf7b9795fd7","title":"2024年度总结","content":"Part 1: ACM\n比赛\n去各地比赛的地图（标签可拖动）\n网页里写的很全了，我文字也写一下吧，中间有很多坎坷，也有很多心路历程，但已经在别处记录过了，就不再赘述\n4月，团体程序设计天梯赛二等奖\n4月，浙江省大学生程序设计竞赛季军\n5.12，河南省大学生程序设计竞赛第六名\n5.19，北京市大学生程序设计竞赛银奖\n5.27，山东省大学生程序设计竞赛季军\n10.20，全国大学生程序设计竞赛哈尔滨站银奖\n11.3，国际大学生程序设计竞赛南京站金奖\n11.10，全国大学生程序设计竞赛重庆站季军（与PKU随机匹配在榜单上并列第二哦）\n\n11.17，国际大学生程序设计竞赛上海站银奖\n12.29，国际大学生程序设计竞赛东亚赛区总决赛银奖\n12.30，华为挑战赛202名，铁牌（删边我嫌哈希、map和unordered_map慢，竟然用vector+重构去做，直接一个十倍常数，我简直是天才，这些数据结构慢那这些存在的意义是啥）\n至此，我十一年半的算法竞赛生涯（2013.8~2024.12）也算是圆满落幕了。其实未来的日子肯定还是会总是和算法竞赛打交道，但身份变了，心态变了，结束了就是结束了。希望离开算法竞赛后，我依旧可以绽放自己的光芒。\n出题&amp;验题\n今年在内蒙省赛、杭电多校、校新生赛上各出了一道题，帮雄哥小验了一下广西省赛（就验了一道，但也算验题人是吧）。\n内蒙省赛用的是我初一出的一道题，完全没改动，没想到全省只有两个队过（甚至不如我不打acm但极其天才的室友，给了点提示人家就能做出来）。\n\n我着重讲一下杭电多校出的那道题吧，出完这道题的时候我整个人都惊了，这种难度的题我自己都很少很少能做出来，结果竟然被我出出来了。并且幸亏一队在验题的时候验出我题目的错误，不然就是丢大人了，而不是光辉事迹。\n给大家看一下战绩：\n全国打杭电多校的大学生队伍就四个队做出来，三支是PKU，高中生的话多俩杭二和南外的队伍。我何德何能啊。\n\n题目： 且  ，求有序数对  数量，答案对取模\n题解就不放在这了，放了跑题了……\nPart 2: 数模\n美赛的名额是靠acm金软磨硬泡出来的，训了两次就正式比赛了，拿了M奖非常的意料之外，因为之前只在新生赛做过一次数模，就一个成功参赛奖。跟她俩确实也学到很多数模的经验。但打完以后，我可以说就出师了，要学的东西很少，或者说都是可以现学的。\n有了美赛的经历，加上周慧的鼓动，还有我需要保研的特推名额等种种因素，让我决定打国赛。软磨硬泡*2，训练三次就去打国赛。王景煜是个特别强的队友，文本、建模、代码都很顶级，只可惜周慧这货纯傻逼，之前打美赛根本没看清这个人，这直接导致最后只拿到了国二。\n通过聊天记录说明一下国二的原因吧\n  \n控诉一下周慧的n宗罪：完全听不懂我们的建模瞎出主意、二维的题目直接拿GPT生成三维的模型用、比赛期间游戏打到凌晨五点早上不来做题、问题复述都写不端正、没事干就在旁边打游戏干扰我们、抄个数据抄错了还是王景煜找出来的错误……但凡她有点正贡献，给我省下三四个小时的时间，我所有代码的变步长搜索的手动调参都可以改成自动调参，这也是我本来就要改的东西。她这些行为直接导致所有文本建模都是王景煜一人完成的，代码和结果都是我完成的，而且独立运作，到提交我都没有细看过一遍论文！\n \n中国大学生助手查的\nPart 3: 一些不算项目的项目或未完成的项目\n华为嵌入式软件大赛\n初赛交了个输出0的代码，结果直接进复赛了。但我真没想好好打复赛，练习赛就草草写了个还跑不出的代码就去杭研所了，没想到最后跑出来了，还跑了22w分，第六名。一共开放了三个月的时间大概，我就做了一个下午+一晚上+比赛的五个小时就第六了，真是意外。\n三维重建\n题目就是给定rgb图、深度图和相机内参，重建模型和渲染。\n主要靠的龙哥和慧源。但我该做的也都做了，nerf跟着跑了，sam分割图像部分我做了，还做了个手动标点的小工具。但最后就19名，也没成果产出，用的都是开源的东西，似乎也不好放进简历，算是个小锻炼吧。\n微表面建模\nstill working\nPart 4: 一些零零散散的小收获\n虽然标题是小收获，但合在一起是我这一年最最最大的收获，这些才是我在大学里最想要获得的东西。\n健身\n3月开始划水到现在，小有成效。体重从120增到了140，能稍微看出点肌肉了（但对于健身人来讲就是，排骨精=&gt;毫无健身痕迹。慢慢练吧，右手有缺陷，强度大会痛，上限就摆在这）。体测的时候引体硬拉15个，立定跳远两米八（其实我觉得是2.85），卧推可以40kg做十几个，我挺满意的，嘻嘻。\n唱歌\n基本功一直不大扎实，且不大学的会（真的已经很努力了，大一天天去楼梯间，之前还花了小两千买线上课自己学，真学不会），待在合唱队感觉好自卑。所以干脆退了合唱队的训练群，自己瞎练。还真给我练出点东西来了，不过都不是服务于舞台的，主要应用场景还是自嗨或者和朋友嗨。\nHigh D, 不是假音哦\n咽音、怒音、撕裂音、C6的头声都解锁了，且都已经在KTV中多次应用。不过离登台的演唱还是差太多，希望未来有一天可以在舞台上用。\n3.24看了张杰演唱会上海站，5月123场外看了两场演唱会。张杰的唱过的歌我现在至少会唱一百首！\n12.22看了邓紫棋演唱会厦门站，本来她杭州站就抢到票的，因为比赛前两站发挥太差，不想因为演唱会影响之后的上海站比赛，扣了一百多手续费，含泪把票退了……\n理论计算机（TCS）\n今年四月份转的专业方向，在这之前还是一直有在读论文和寻找tcs的idea的，是占用我时间的最大头。虽然有人“挖苦”我，在这上面白花这么多时间，但我其实并不后悔。哪怕没有产出，其中的体悟都是留在我的记忆中的。比如有一个感悟就是这个世界就是存在很多无法用简洁语言描述的东西。即便是正态分布、傅里叶变换的公式我也会觉得很简洁很优美，但tcs真给我当头一棒，全都是那种恶心到爆，还无法简化的证明。正是在书桌前一整天一整天的绞尽脑汁，才让我真的认命。\n思想\n其实我认为这一年进步最大的是我的思想，它比较抽象所以我也没放上面说。我遇到了许许多多的人、碰到了许许多多的困难，也有许许多多开心的事情让我回味。和人打交道让我越来越像个人了，能渐渐把“抽象”变成“幽默”（以前真不是人吧，用lsh的话讲就是“是不是刚来地球”），解决一个又一个我以为我解决不了的困难也我有了面对一切困难的勇气。总的来说，一切都在越来越好，这一年我捋清楚了我是怎样一个人，我要干什么，我的未来在哪里，成功回答了去年留给自己的那些疑问。希望新的一年，一切都能变得更好！！！\nEntertainment\n用英语显得正经一点，符合文章的基调。\n今年打了老多游戏。特别是装了双系统之后，4070s+1TB的游戏+潘泽宇300多个游戏的账号，真的如虎添翼如鱼得水。黑猴、传送门、Dying Light、地平线……但玩了一圈发现还是原神、箭箭剑这种好玩儿。以后可以考虑玩奇迹暖暖[doge]\n游戏玩厌了，感觉追剧贼有意思。永夜星河和其团综刚看完，月光变奏曲、九重紫啥的都是接下来想看的。感觉玩游戏可累了，追剧一点都不累，还养眼。\n一些更琐碎、难分类的东西\n比如上面用高德api做的地图、比如搭了博客、比如花了三天时间自己装的电脑\n还有双放手很熟练喽，都可以转弯了，录的视频不多，只能放一下这个有点丢人的了\n双放手录视频+唱歌，九十度弯摔了\n当了班助，排了节目（没上心，所以效果确实差了点，但完成任务就挺好了），加了朗诵社，认识了很多新的朋友，新生们也都很有意思。可惜班里人数太多，新生谈话没法谈得很久，本来还挺享受这种和两年前的我交流的感觉的，我也很喜欢代入一个个同学的角度进行分析。本以为这学期会比较闲，朗诵社可以全勤了，没想到请了一半的假……真是有点……\n8.1组织了同学聚会，不得不说，召集和组织八年未见的老同学们还是颇有难度的。从开始的建群拉人到中间定时间定酒店，每个步骤都能碰到问题。核心的难点线上通知下达落实的太慢，以及无法兼顾每个人的情绪。当时也挺害怕自己搞砸的。不过一切都顺利完成，并且和好多小学的同学都恢复了联系！\n化妆会了一捏捏，但几乎完全不用，或者说只有不见人的时候才会自己玩玩。双眼皮贴会贴了，直板夹能稍微夹出点纹理，素颜霜会涂，知道化妆的流程，所以也没很卡粉，还能消黑眼圈和遮痘印。\n拍了写真，去厦门玩的时候也拍了很多照片，觉得自己虽然现在不行，但还是有变帅的潜力在的，收获了一点点自信。\n进行了国奖答辩、科创先锋、笃学模范、青年领英的答辩，颇有收获，知道了汇报的重心、评奖的机制和其核心要领等等（不细讲了，这部分就写给自己看一下），希望明年能汲取今年积累的经验，百战百胜。\n干了两件半大事，大事是什么我不说。\n对2025的展望\n总是说着要摆烂要摆烂，结果不知不觉还是干了一件又一件事，甚至下学期很多事也找了上门，我会想办法推掉一点。\n工作的机会、保研的机会、挣钱的机会……我总是想不错过任何一个机会，但若是一直这样，我对学习外事物的热情会一点点被消磨殆尽。列了几十件想干的事了，虽然有的太天马星空难以实现，但怎么说也去做一点吧，不然这一辈子也太无趣了。我总是想着现在努力了，以后就可以少努力一点，可我现在觉得，越努力，之后越是有的努力，越吃苦，越是要吃一辈子的苦，所以别把时间荒废在学习上了，给我去玩！\n新的一年，我要做到以下四点：活得轻松一点，想法简单一点，性格阳光一点，每天开心一点。别的么，走一步看一步吧。\n","slug":"2024年度总结","date":"2024-12-09T08:30:10.000Z","categories_index":"","tags_index":"杂","author_index":"蜗角虚名羊"},{"id":"f3e053b17563d4376eb93323aa914ede","title":"搭建过程记录","content":"hexo官方文档\n以下是自己的搭建过程（包括怎么git）：\n1. 建立名为 username.github.io的储存库\n2. first commit\n123456789(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~$ mkdir blog(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~$ cd blog(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependenciesINFO  Start blogging with Hexo!(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$  git push -u origin mainfatal: 不是 git 仓库（或者直至挂载点 / 的任何父目录）停止在文件系统边界（未设置 GIT_DISCOVERY_ACROSS_FILESYSTEM）。\n完全按hexo步骤来会在这步卡住，因为git仓库都没有初始化\n1234567891011(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ echo \"# xmy1107.github.io\" &gt;&gt; README.md（这里漏了git init，这个记得输入）(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git add README.md(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git commit -m \"first commit\"[main （根提交） 8956e78] first commit 1 file changed, 1 insertion(+) create mode 100644 README.md(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote add origin https://github.com/xmy1107/xmy1107.github.io.git(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git push -u origin mainUsername for 'https://github.com': xmy1107Password for 'https://xmy1107@github.com': \n这里初始化并进行第一次提交以后就建站成功了。注意password不是你用户的密码，而是personal access token。如果是ssh连接就是这样（我用PAT能登进去，但每次都要重新输入，但用ssh在把公钥放进去以后不用这样，就用ssh了）：\n12345678910111213(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote get-url originhttps://github.com/xmy1107/xmy1107.github.io.git(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote set-url origin git@github.com:xmy1107/xmy1107.github.io.git(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote get-url origingit@github.com:xmy1107/xmy1107.github.io.git(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git push -u origin main枚举对象中: 3, 完成.对象计数中: 100% (3/3), 完成.写入对象中: 100% (3/3), 227 字节 | 227.00 KiB/s, 完成.总共 3（差异 0），复用 0（差异 0），包复用 0To github.com:xmy1107/xmy1107.github.io.git * [new branch]      main -&gt; main分支 'main' 设置为跟踪 'origin/main'。\n然后在 https://xmy1107.github.io/ 下就有一个空的网页：\n\nps：PAT想要不每次输密码可以尝试\nvim ~/.gitconfig后输入以下内容（虽然我没成功）\n1234567[init]        defaultBranch = main[user]        name =         email = [github]        token = \n3. 网站正式建立\n上面是因为只push了一个README，下面对github工作流配置后再次push可以得到”正常“的一个网页\n\n\n使用 node --version 指令检查你电脑上的 Node.js 版本。 记下主要版本（我是v20.17.0）\n\n\n在储存库中前往 Settings &gt; Pages &gt; Source 。 将 source 更改为 GitHub Actions，然后保存。\n\n\n在储存库中建立 .github/workflows/pages.yml，并填入以下内容 (将 20 替换为上个步骤中记下的版本)：\n\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.github/workflows/pages.ymlname: Pageson:  push:    branches:      - main # default branchjobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4        with:          token: ${{ secrets.GITHUB_TOKEN }}          # If your repository depends on submodule, please see: https://github.com/actions/checkout          submodules: recursive      - name: Use Node.js 20        uses: actions/setup-node@v4        with:          # Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node          # Ref: https://github.com/actions/setup-node#supported-version-syntax          node-version: \"20\"      - name: Cache NPM dependencies        uses: actions/cache@v4        with:          path: node_modules          key: ${{ runner.OS }}-npm-cache          restore-keys: |            ${{ runner.OS }}-npm-cache      - name: Install Dependencies        run: npm install      - name: Build        run: npm run build      - name: Upload Pages artifact        uses: actions/upload-pages-artifact@v3        with:          path: ./public  deploy:    needs: build    permissions:      pages: write      id-token: write    environment:      name: github-pages      url: ${{ steps.deployment.outputs.page_url }}    runs-on: ubuntu-latest    steps:      - name: Deploy to GitHub Pages        id: deployment        uses: actions/deploy-pages@v4\n这个过程相当于hexo generate和hexo deploy，区别是在git push时才执行，然后用github工作流完成渲染和部署。\n这一步结束后重新打开博客便是如下页面：\n\n\n部署完成后，前往 username.github.io/repository 查看网页。\n\n4.一键部署\n\n安装 hexo-deployer-git，即输入npm install hexo-deployer-git --save\n在 _config.yml 中添加以下配置（如果配置已经存在，请将其替换为如下）:\n\n1234567deploy:  type: git  repo: https://github.com/&lt;username&gt;/&lt;project&gt;  # example, https://github.com/hexojs/hexojs.github.io  # 我这里是git@github.com:xmy1107/xmy1107.github.io.git，因为我是ssh连接的  # git@github.com:xmy1107/blog.git是项目页面  branch: main # hexo给的是gh-pages，无所谓\n\n这里要把网站建立中GitHub Actions改回Deploy from a branch，因为使用 hexo d 时，它会跳过 GitHub Actions，直接将 public 文件夹中的静态文件推送到 gh-pages 分支。 GitHub Actions对应的操作是git push\n执行 hexo clean &amp;&amp; hexo deploy 。\n浏览 username.github.io，检查你的网站能否运作。\n\n5.后续配置\n主题选用Academia\n改用aurora\n6.Aurora\n见doc\nGitalk\n创建一个 comments 仓库，配置一下 OAuth App 即可\n12345678910111213gitalk:  enable: true  autoExpand: true  clientID: ''  clientSecret: ''  repo: 'blog-comments' ## dev-blo-comments  owner: 'xmy1107' ## owner name  admin: ['xmy1107'] ## ['admin_name']  id: location.pathname  language: en  distractionFreeMode: true  recentComment: true  proxy: ''\n开始一直无法启用是因为一直在本地测试，而 GitHub OAuth 不允许本地地址作为 Authorization callback URL，redirect_uri 一直与其冲突。部署上去就大功告成了！\n对话功能\n一个简单的示例：\n \n在/home/xmy/blog/node_modules/hexo-theme-aurora/layout下修改index.ejs中代码为：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt;    &lt;link rel=\"icon\" href=\"/favicon.ico\"&gt;    &lt;script type=\"module\" crossorigin src=\"/static/js/120aa8f8.js\"&gt;&lt;/script&gt;    &lt;link rel=\"stylesheet\" href=\"/static/css/a14e1a22.css\"&gt;    &lt;!-- 引入 KaTeX --&gt;    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css\"&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js\"&gt;&lt;/script&gt;    &lt;!-- 引入 marked.js 和 DOMPurify 库 --&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js\"&gt;&lt;/script&gt;    &lt;style&gt;        #aurora-chatbox {            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;            opacity: 0;            transform: translateY(10px);        }        #aurora-chatbox.active {            opacity: 1;            transform: translateY(0);        }    &lt;/style&gt;&lt;/head&gt;&lt;body id=\"body-container\"&gt;    &lt;noscript&gt;        &lt;strong&gt;We're sorry but this app doesn't work properly without JavaScript enabled.            Please enable it to continue.&lt;/strong&gt;    &lt;/noscript&gt;    &lt;div id=\"app\"&gt;&lt;/div&gt;    &lt;button id=\"showChatbox\" style=\"    position: fixed;    bottom: 20px;    left: 20px;    width: 80px;    height: 80px;    padding: 0;    background-color: #007bff;    color: white;    border: none;    border-radius: 50%;    font-size: 16px;    cursor: pointer;    z-index: 10000;    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);    opacity:0;\"&gt;    聊天    &lt;/button&gt;    &lt;!-- Aurora 机器人聊天框，固定在页面左下角 --&gt;    &lt;div id=\"aurora-chatbox\" style=\"    position: fixed;    bottom: 200px;    left: 20px;    width: 350px;    background: linear-gradient(to bottom right, #ffffff, #f1f7ff);    border: none;    border-radius: 12px;    box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.1);    z-index: 9999;    font-family: Arial, sans-serif;    overflow: hidden;    \"&gt;    &lt;!-- 标题栏 --&gt;    &lt;!-- &lt;div style=\"        background-color: #007bff;        color: #ffffff;        padding: 10px 15px;        font-size: 16px;        font-weight: bold;        border-top-left-radius: 12px;        border-top-right-radius: 12px;        text-align: center;\"&gt;        Aurora 聊天机器人    &lt;/div&gt; --&gt;    &lt;!-- 聊天框主体 --&gt;    &lt;div style=\"        padding: 15px;        display: flex;        flex-direction: column;\"&gt;        &lt;p style=\"margin: 0; font-size: 14px; color: #333; margin-bottom: 8px;\"&gt;            和我聊天吧🤖        &lt;/p&gt;        &lt;input type=\"text\" id=\"userInput\" placeholder=\"输入你的问题...\"            style=\"                width: calc(100% - 10px);                padding: 8px;                margin: 0 auto;                border-radius: 8px;                border: 1px solid #ddd;                box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);                transition: all 0.3s ease;\" /&gt;        &lt;button id=\"sendMessage\" style=\"                margin-top: 10px;                padding: 10px 15px;                background-color: #007bff;                color: white;                border: none;                border-radius: 8px;                font-size: 14px;                cursor: pointer;                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);                transition: background-color 0.3s ease;\"&gt;            发送        &lt;/button&gt;        &lt;div id=\"responseBox\" style=\"                margin-top: 15px;                min-height: 50px;                font-size: 12px;                color: #555;                background: #f9f9f9;                border-radius: 8px;                padding: 8px;                box-shadow: inset 0px 1px 3px rgba(0,0,0,0.05);                overflow-y: auto;\"&gt;            &lt;!-- 机器人响应展示 --&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;/div&gt;    &lt;!-- JavaScript 逻辑 --&gt;    &lt;script&gt;        // document.getElementById(\"showChatbox\").addEventListener(\"click\", function () {        //     const chatbox = document.getElementById(\"aurora-chatbox\");        //     if (chatbox.style.display === \"none\" || chatbox.style.display === \"\") {        //         chatbox.style.display = \"block\"; // 显示聊天框        //     } else {        //         chatbox.style.display = \"none\"; // 隐藏聊天框        //     }        // });        document.getElementById(\"showChatbox\").addEventListener(\"click\", function () {            const chatbox = document.getElementById(\"aurora-chatbox\");            if (!chatbox.classList.contains(\"active\")) {                chatbox.classList.add(\"active\"); // 显示聊天框            } else {                chatbox.classList.remove(\"active\"); // 隐藏聊天框            }        });        //开发者平台：https://platform.moonshot.cn/console/api-keys        const API_URL = \"https://api.moonshot.cn/v1/chat/completions\"; // Kimi AI的API地址        const API_KEY = \"YOUR-KEY\"; // 替换为您的Kimi API密钥            async function sendMessage() {            const userInput = document.getElementById(\"userInput\").value.trim();            const responseBox = document.getElementById(\"responseBox\");                if (!userInput) {                responseBox.innerText = \"请输入你的问题！\";                return;            }                responseBox.innerText = \"思考中，请耐心等候（需要10秒左右）...\";                try {                // 发起 Kimi AI API 请求                const response = await fetch(API_URL, {                    method: \"POST\",                    headers: {                        \"Content-Type\": \"application/json\",                        \"Authorization\": `Bearer ${API_KEY}`                    },                    body: JSON.stringify({                        model: \"moonshot-v1-8k\", // Kimi 模型名称                        messages: [                            { role: \"system\", content: \"你是一个网站的助手，下面我会给你一些这个网站的相关信息。\\                            \\n网站的主人叫虚名羊，网站是用hexo搭建的，网站链接是https://xmy1107.github.io/，\\                            内容以技术和生活为主。\" },                            { role: \"user\", content: userInput }                        ]                    })                });                    if (!response.ok) {                    throw new Error(\"API 请求失败，请检查网络或密钥。\");                }                    const data = await response.json();                const kimiResponse = data.choices[0]?.message?.content || \"未获取到有效响应内容。\";                console.log(\"Kimi Response:\", kimiResponse);                    // 渲染处理与数学公式展示                const placeholder = '%%MATH_FORMULA%%';                let mathBlocks = [];                    // 预处理数学公式                const preprocessedResponse = kimiResponse.replace(/\\\\\\[.*?\\\\\\]|\\\\\\(.*?\\\\\\)/gs, (match) =&gt; {                    mathBlocks.push(match);                    return placeholder;                });                    // 使用 marked 渲染 Markdown                const renderedHTML = marked.parse(preprocessedResponse);                    // 替换占位符回原始数学公式                let finalHTML = renderedHTML;                mathBlocks.forEach((math, i) =&gt; {                    finalHTML = finalHTML.replace(placeholder, math);                });                    // 安全插入 HTML 并渲染数学公式                responseBox.innerHTML = DOMPurify.sanitize(finalHTML);                renderMathInElement(responseBox, {                    delimiters: [                        { left: \"\\\\(\", right: \"\\\\)\", display: false }, // 行内公式                        { left: \"\\\\[\", right: \"\\\\]\", display: true }  // 块级公式                    ],                    throwOnError: false                });            } catch (error) {                responseBox.innerText = \"抱歉，出错了：\" + error.message;            }                // 清空输入框            document.getElementById(\"userInput\").value = \"\";        }            // 事件监听：发送按钮和回车键        document.getElementById(\"sendMessage\").addEventListener(\"click\", sendMessage);        document.getElementById(\"userInput\").addEventListener(\"keydown\", function (event) {            if (event.key === \"Enter\") {                event.preventDefault();                sendMessage();            }        });    &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;\n令我最头疼的点：正则表达式识别\n小小记录下：\n.*?：非贪婪匹配，匹配中间的任意字符，直到遇到下一个 \\] 为止。\ns 标志：启用 dotall 模式，使 . 匹配换行符。\ng 标志：全局匹配。\nupd：改kimi ai了，gpt有的人可能用不了。\n一些自己写博客的注意点\n关于贴html\n贴html用绝对路径：[去各地比赛的地图（标签可拖动）](/htmls/map.html)\n贴图片用相对路径：![image-20240925134647445](搭建过程记录/image-20240925134647445.png)\n因为渲染后所有静态网页都在 public/post 中，不管这里的绝对还是相对，都是基于根目录为 public 的路径，图片用相对路径是为了编辑时也可以预览，因为图片相对于当前都是 ${filename}/image_name.png，现在在 Typora 中编辑且设置好路径表示的偏好就很方便，直接粘贴即可。\nhtml文件要禁止渲染，默认会渲染并且放进page目录中。需要在config中加入以下配置：\n12skip_render:  htmls/**/*.html\n要放进地址栏的部分得用英文字符，但只是文件链接就不用\n[双放手录视频+唱歌，九十度弯摔了](/htmls/双放手.html)\nhtml文件中是\n1234&lt;video controls width=\"500\"&gt;    &lt;source src=\"/videos/shuangfangshou.mp4\" type=\"video/mp4\"&gt;    您的浏览器不支持视频标签。&lt;/video&gt;\n本地的目录，供以后参考\n\nhexo s后台运行\n\n数学公式\nhexo-filter-mathjax\n记得front-matter里加上mathjax: true\n公式换行需要\\\\\\\\\n需要_config.yml把highlight enable一下，不然只有部分公式可以显示，不知道原理\nTODO LIST\n小机器人可以想办法搞得更生动一点\n用nodejs啥的把api封装到后端（目前感觉没啥关系，小白不在乎安全性）\n代码高亮真的搞不好，主题必须要shiki高亮引擎，而shiki是一个ES Module，与hexo环境不兼容。\n没搞清楚的部分\n项目页面（这部分没完全搞清楚）\n\n导航到 GitHub 上的存储库。 转到 Settings 选项卡。 建立名为 &lt;repository 的名字&gt; 的储存库，这样你的博客网址为 &lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;，repository 的名字可以任意，例如 blog 或 hexo。\n编辑你的 _config.yml，将 url: 更改为 &lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;。\n在 GitHub 仓库的设置中，导航至 Settings &gt; Pages &gt; Source 。 将 source 更改为 GitHub Actions，然后保存。\nCommit 并 push 到默认分支上。\n\n注意这里要修改远程的仓库，需要push到新建的那个仓库中\n1234567891011121314151617181920212223242526(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote set-url origin git@github.com:xmy1107/blog.git(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git remote -vorigin\tgit@github.com:xmy1107/blog.git (fetch)origin\tgit@github.com:xmy1107/blog.git (push)(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git add .(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git status位于分支 main您的分支与上游分支 'origin/main' 一致。要提交的变更：  （使用 \"git restore --staged &lt;文件&gt;...\" 以取消暂存）\t修改：     _config.yml(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git commit -m \"first commit\"[main fa6cdc7] first commit 1 file changed, 1 insertion(+), 1 deletion(-)(base) xmy@xmy-Z790M-AORUS-ELITE-AX:~/blog$ git push枚举对象中: 30, 完成.对象计数中: 100% (30/30), 完成.使用 16 个线程进行压缩压缩对象中: 100% (19/19), 完成.写入对象中: 100% (30/30), 31.32 KiB | 3.48 MiB/s, 完成.总共 30（差异 3），复用 0（差异 0），包复用 0remote: Resolving deltas: 100% (3/3), done.To github.com:xmy1107/blog.git * [new branch]      main -&gt; main","slug":"搭建过程记录","date":"2024-11-07T03:07:08.000Z","categories_index":"","tags_index":"杂","author_index":"蜗角虚名羊"}]