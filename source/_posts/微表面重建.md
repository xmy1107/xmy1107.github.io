---
title: 微表面重建
date: 2024-12-19 15:01:21
tags:
    - 三维重建
---
没完工，也不知道最后能成什么样。我纯是抱着学习的心态，甚至能不能有成果都无所谓，做了多少记录多少好了。

# 整体流程
整个流程可以分为以下几个部分：

 - 在待测物体和校准使用的镜子上粘贴 ArUco 标记。

 - 图像采集（这部分通过另一个独立程序完成）。

 - 内参标定（Intrinsic Calibration）。

 - 几何标定（Geometric Calibration）。

 - 辐射标定（Radiometric Calibration）。

 - 表面法线计算（Surface Normal Calculation）。

# 漫反射表面法线计算

计算表面法线的代码异常简单，只需如下步骤：
```python
self.diff_x = frames_x_n[..., 1] - frames_x_n[..., 0]
self.diff_y = frames_y_n[..., 1] - frames_y_n[..., 0]
z = np.sqrt(1 - np.square(self.diff_x) - np.square(self.diff_y))
```
其中`frames_x_n[..., 0]`，`frames_x_n[..., 1]`是屏幕顺着$x$方向分别从亮到暗和从暗到亮打光到物体表面后拍摄的两张图。

看了[SKINSCAN论文](https://arxiv.org/pdf/2102.00508)，研究了几天终于研究出来了（论文里就两行公式，包括条件，全得自己脑补）。

提前说一下有两个条件要满足：
1. 屏幕正对物体
2. 假设屏幕与物体相比足够大

回顾双向反射分布函数（BRDF），
$$
L_r(\mathbf{p}, \omega_r) = \int_{H^2} f_r(\mathbf{p}, \omega_i \to \omega_r) L_i(\mathbf{p}, \omega_i) \cos \theta_i \, d\omega_i
$$
在这里，假设物体有朗伯反射特性，表面在所有方向上的辐射率都是均匀的，令
$$
R(\vec{\omega}, \vec{n}) = \rho_d \cdot \max(\vec{\omega} \cdot \vec{n}, 0)
$$
则，
$$
r(\vec{v}) = \int_{\Omega} P_i(\vec{\omega}) R(\vec{\omega}, \vec{n}) d\vec{\omega}
$$
其中：\
$P_i(\vec{\omega})$：屏幕上生成的光图案，作为入射光的分布。\
$R(\vec{\omega}, \vec{n})$：定义表面材料的反射特性。\
$\rho_d$：衡量材料对入射光的漫反射能力。\
$\vec{\omega}$：描述入射光的方向。\
$\vec{n}$：定义表面的法向量，影响光与表面交互的方向性。

屏幕是个面光源，假设物体表面坐标 $(x_0,y_0,0)$ 确定，其法向量为 $(x_n,y_n,z_n)$ ，对屏幕表面的每个点 $(x,y,1)$ 积分，根据BRDF计算该点在两个场景中收到的辐射：

$$
I_1=\int_0^W \int_0^H  \frac{x}{W}\cdot 255 \cdot \rho_d \cdot max\left( \frac{(x - x_0) \cdot x_n + (y - y_0) \cdot y_n + z_n}{\sqrt{(x - x_0)^2 + (y - y_0)^2 + 1}},0 \right) dy \ dx
$$

$$
I_2=\int_0^W \int_0^H  (1-\frac{x}{W})\cdot 255 \cdot \rho_d \cdot max\left( \frac{(x - x_0) \cdot x_n + (y - y_0) \cdot y_n + z_n}{\sqrt{(x - x_0)^2 + (y - y_0)^2 + 1}},0 \right)  dy \ dx
$$

由于屏幕正对物体，所以 $\vec{\omega}$ 和 $\vec{n}$ 点积一定大于 $0$ ，不用 $max$，忽略系数可以得到：
$$
I_1-I_2=k\int_0^W \int_0^H  (\frac{2x}{W}-1)\cdot \frac{(x - x_0) \cdot x_n + (y - y_0) \cdot y_n + z_n}{\sqrt{(x - x_0)^2 + (y - y_0)^2 + 1}}  dy \ dx
$$
公式有点丑，调整一下：
$$
I_1-I_2=k'\int_{-\frac{W}{2}}^{\frac{W}{2}} \int_{-\frac{H}{2}}^{\frac{W}{2}}  x\cdot \frac{(x - x_0 + \frac{W}{2}) \cdot x_n + (y - y_0+\frac{H}{2}) \cdot y_n + z_n}{\sqrt{(x - x_0+\frac{W}{2})^2 + (y - y_0+\frac{H}{2})^2 + 1}}  dy \ dx
$$

此时发现，如果$x_0=\frac{W}{2},y_0=\frac{H}{2}$，则
$$
I_1-I_2=k'\int_{-\frac{W}{2}}^{\frac{W}{2}} \int_{-\frac{H}{2}}^{\frac{W}{2}}  \frac{x^2 \cdot x_n + x\cdot y \cdot y_n + x\cdot z_n}{\sqrt{x^2 + y^2 + 1}}  \, dy \, dx = k' \cdot x_n\int_{-\frac{W}{2}}^{\frac{W}{2}} \int_{-\frac{H}{2}}^{\frac{W}{2}}  \frac{x^2}{\sqrt{x^2 + y^2 + 1}}  dy \ dx
$$
在屏幕足够大的情况下，可视为这种情况，故法向量在 $x$ 方向上的值与 $I_1-I_2$ 成正比。

# 碰到的困难（随手记）

```
Q：8_11_checker.npz得想办法自己搞一个出来
A：搞出来了以后发现并不需要，它mirror数据中确实是8*24的

Q：imgDistortFilelist = readFileList(imgDistortFolder)竟然能出错
A：断点定错了，是读该目录下文件出现的问题

Q：h, w = imgDistort.shape[:2]，明明看图像明显可以看出宽>高，但输出shape是2448，2048，高>宽
A：shape没问题，(6692, 7996, 3)，是我搞错了，shape属性和图像显示工具的宽高定义方式不同
shape是(h,w,3)；图像显示工具是w*h；坐标轴是x为宽，y为高

Q：高阶径向很大，导致结果很不理想
[[-1.79807615e+00 -1.51664935e+00  2.15608648e-03  9.33400363e-04
   2.45988598e+00 -1.72972173e+00 -1.76633092e+00  2.70524422e+00
   0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
   0.00000000e+00  0.00000000e+00]]
A：关闭原代码中的cv2.CALIB_RATIONAL_MODEL选项，重新运行，畸变系数如下
[[-0.06838548  0.1297082   0.00215606  0.00093164 -0.10610527]]
但结果还是不理想\
继续Q：fxfy对焦问题？cxcy图像中心？标定图像？
A：我在计算相机内参时的图像分辨率为2448*2048像素，而需要反畸变的图像分辨率为7996*6992，我觉得这是反畸变失败的核心原因，焦距和光学中心在新的图上都失效了
解决方案是缩放，终于得到正确结果了呜呜呜

Q：geometric calibration检测不到checker board，代码都是原先的，似乎数据上有问题。到底是因为镜子尺寸不同，
还是arucoBoardHeight= 0.2884, arucoBoardWidth= 0.5932有问题？
half_length = 0.2000 - 0.005这部分肯定有问题，我肉眼几乎观察不到边框
A：罪魁祸首img = (img/65535*255).astype(np.uint8)，搞得图全黑了

Q：ARUCO_BOARD_HEIGHT = half_height * 2
    ARUCO_BOARD_WIDTH = half_length * 2
这两句，前面传入的half_height、half_length是镜子的一半高度和宽度，在这里变成了aruco board的高度和宽度，
A：好吧一样，但是checker board的数据消失了

Q：整张图绿油油的
A：frame_markers = aruco.drawDetectedMarkers(img.copy(), corners, ids)输入BGR，返回BGR，但matplotlib用的是RGB

Q：镜子放反了。相机内参是不能变动的，图像翻转180度可以视为世界翻转了180度，理论还是能继续实验，但还是不行
A：相机内参也变了似乎

Q：id为4的aruco标记左上角坐标为1885., 1270.，理论是正确的，但在图中发生偏移
A1：reProjAruco中没用到检测的aruco
A2：前面检测的aruco已经把位姿 (rvec, tvec)计算出了，通过位姿重投影，然后函数前面的默认值没有修改，导致投影错误

Q：标记只能检测出4个，重投影计算正确，但后续工作无法继续进行
A：换了张图ok了，可能光线强了点，这个要看运气

Q：重影极其严重
A1：畸变出了问题，flags=cv2.CALIB_FIX_K3忽略高阶径向畸变可以基本解决
A2：基本可以视为没有问题了，因为普通镜头通常不会需要高阶修正。下次可以多拍几张图片，并且把镜子尽可能放正来减小切向畸变的影响。然后修改参数重新试一试

Q：aruco的重投影啥的都没问题，但是z轴反了，才发现
A：说是可以不用管

Q：PMD的结果很奇怪
A：得到相位图需要分别投射同一频率的多幅光栅图像至物体表面用以获得物体表面信息对应相位，一组图像之间有固定的相位差，这里没有这么做，也没有这个需求

Q：calibration.npz和PhaseMapHV.npz的导出
A：ok

Q：还是有重影
A：通过比较反畸变后图片，认为径向畸变的量计算有误，标定板不光要各个角度，还要尽可能在屏幕边缘

Q：could not broadcast input array from shape (4194304,) into shape (5013504,)
A：原本代码的height和width有一些错误，参看前文宽和高
```